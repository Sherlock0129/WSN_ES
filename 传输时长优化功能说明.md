# 传输时长优化功能说明

## 功能概述

**传输时长感知调度器（DurationAwareLyapunovScheduler）** 是一个创新的能量传输调度算法，它将**传输时长**作为新的优化维度，综合考虑能量传输量、AoI（信息年龄）和信息量的权衡。

### 核心创新

在传统调度算法中，每次能量传输的量是固定的（每分钟传输 `E_char` 焦耳）。而新算法引入了一个关键问题：

**"应该传输多长时间？"**

- 传输 **1分钟** → 传输 500J
- 传输 **2分钟** → 传输 1000J
- 传输 **3分钟** → 传输 1500J
- ...
- 传输 **5分钟** → 传输 2500J

## 设计原理

### 1. 多目标优化框架

传输时长的选择需要权衡多个目标：

| 维度 | 传输时间越长的影响 | 权衡考虑 |
|------|------------------|---------|
| **能量传输量** | ↑ 传输更多能量，receiver获得更多补充 | ✅ 正面收益 |
| **能量损耗** | ↑ donor消耗更多，路径损耗更大 | ❌ 负面代价 |
| **AoI增长** | ↑ 传输期间其他节点的信息老化 | ❌ 负面代价 |
| **信息量累积** | ↑ 传输期间可以累积更多信息"搭便车" | ✅ 正面收益 |

### 2. 综合得分函数

对于每个donor-receiver对，对每种可能的传输时长（1-5分钟），计算综合得分：

```python
score = (能量收益 × Q权重) - (能量损耗惩罚) - (AoI惩罚) + (信息量奖励)
```

其中：
- **能量收益** = `duration × E_char × η × Q_normalized`
  - `η`：路径传输效率
  - `Q_normalized`：归一化的能量缺口（越缺能量的节点权重越高）
  
- **能量损耗惩罚** = `V × (duration × E_char - 送达能量)`
  - `V`：Lyapunov控制参数
  
- **AoI惩罚** = `w_aoi × duration × Q_normalized`
  - `w_aoi`：AoI权重（默认0.1）
  
- **信息量奖励** = `w_info × duration × info_rate`（仅当receiver有未上报信息时）
  - `w_info`：信息量权重（默认0.05）
  - `info_rate`：信息采集速率（bits/分钟）

### 3. 最优时长选择

```
对每个donor-receiver对：
    for duration in [1, 2, 3, 4, 5]:
        计算该时长的综合得分
    选择得分最高的时长
```

## 实现细节

### 核心类：`DurationAwareLyapunovScheduler`

**位置**：`src/scheduling/schedulers.py`

**关键参数**：
```python
DurationAwareLyapunovScheduler(
    node_info_manager,     # 节点信息管理器
    V=0.5,                 # Lyapunov控制参数
    K=2,                   # 每个receiver最多接受的donor数量
    max_hops=5,            # 最大跳数
    min_duration=1,        # 最小传输时长（分钟）
    max_duration=5,        # 最大传输时长（分钟）
    w_aoi=0.1,             # AoI惩罚权重
    w_info=0.05,           # 信息量奖励权重
    info_collection_rate=10000.0  # 信息采集速率（bits/分钟）
)
```

### 执行器修改

**`Network.execute_energy_transfer()`** 和 **`NodeInfoManager.apply_energy_transfer_changes()`** 已支持 `duration` 参数：

```python
# 如果plan中包含duration（传输时长），则能量 = duration × E_char
duration = plan.get("duration", 1)  # 默认1分钟
energy_sent = duration * donor.E_char
```

### 配置参数

**位置**：`src/config/simulation_config.py` - `SchedulerConfig`

```python
# DurationAwareLyapunovScheduler 超参数（传输时长优化）
duration_min: int = 1                    # 最小传输时长（分钟）
duration_max: int = 5                    # 最大传输时长（分钟）
duration_w_aoi: float = 0.1              # AoI惩罚权重
duration_w_info: float = 0.05            # 信息量奖励权重
duration_info_rate: float = 10000.0      # 信息采集速率（bits/分钟）
```

## 使用方法

### 1. 在配置中启用

```python
from config.simulation_config import ConfigManager
from scheduling.schedulers import DurationAwareLyapunovScheduler
from acdr.physical_center import NodeInfoManager

config = ConfigManager()

# 调度器参数
config.scheduler_config.scheduler_type = "duration_aware"
config.scheduler_config.lyapunov_V = 0.5
config.scheduler_config.K = 2

# 传输时长参数
config.scheduler_config.duration_min = 1
config.scheduler_config.duration_max = 5
config.scheduler_config.duration_w_aoi = 0.1
config.scheduler_config.duration_w_info = 0.05
config.scheduler_config.duration_info_rate = 10000.0
```

### 2. 创建调度器

```python
# 创建节点信息管理器
nim = NodeInfoManager(
    initial_position=(5.0, 5.0),
    enable_logging=False
)
nim.initialize_node_info(network.nodes, initial_time=0)

# 创建传输时长感知调度器
scheduler = DurationAwareLyapunovScheduler(
    node_info_manager=nim,
    V=config.scheduler_config.lyapunov_V,
    K=config.scheduler_config.K,
    max_hops=config.scheduler_config.max_hops,
    min_duration=config.scheduler_config.duration_min,
    max_duration=config.scheduler_config.duration_max,
    w_aoi=config.scheduler_config.duration_w_aoi,
    w_info=config.scheduler_config.duration_w_info,
    info_collection_rate=config.scheduler_config.duration_info_rate
)
```

### 3. 运行仿真

```python
simulation = EnergySimulation(
    network=network,
    time_steps=1000,
    scheduler=scheduler,
    enable_energy_sharing=True
)

simulation.simulate()
```

## 测试结果

运行 `test_duration_aware_scheduler.py` 的测试结果：

### 传输时长感知调度器
- 规划数量：8个传输
- **平均传输时长：3.5分钟**
- **传输时长分布：{1分钟: 3次, 5分钟: 5次}**
- 总传输能量：14000J

### 标准Lyapunov调度器（对比）
- 规划数量：8个传输
- **平均传输时长：1.0分钟（固定）**
- 总传输能量：4000J

### 关键观察

1. **智能时长选择**：新调度器能够根据具体情况选择不同的传输时长
2. **更多能量传输**：总传输能量是标准调度器的3.5倍（14000J vs 4000J）
3. **差异化策略**：
   - 部分传输选择短时长（1分钟）→ 快速响应，减少AoI
   - 部分传输选择长时长（5分钟）→ 充分传输，利用信息搭便车

## 参数调优建议

### AoI权重 (`w_aoi`)

| 值 | 效果 | 适用场景 |
|----|------|---------|
| `0.05` | AoI影响较小，倾向选择更长传输时长 | 低频更新网络 |
| `0.1` | 推荐值，平衡AoI和能量传输 | 通用场景 |
| `0.2` | AoI影响较大，倾向选择更短传输时长 | 高实时性需求 |

### 信息量权重 (`w_info`)

| 值 | 效果 | 适用场景 |
|----|------|---------|
| `0.02` | 信息量影响较小 | 信息传输不重要 |
| `0.05` | 推荐值，鼓励信息搭便车 | 机会主义信息传递 |
| `0.1` | 信息量影响较大，强烈鼓励搭便车 | 信息传输为主要目标 |

### 传输时长范围

| 范围 | 效果 | 适用场景 |
|------|------|---------|
| `1-3分钟` | 较保守，快速响应 | 网络变化快，需要灵活调整 |
| `1-5分钟` | 推荐值，灵活权衡 | 通用场景 |
| `1-10分钟` | 激进策略，长时间传输 | 稳定网络，长期规划 |

## 优势与局限

### 优势

1. ✅ **多维度优化**：同时考虑能量、AoI、信息量
2. ✅ **自适应决策**：根据网络状态智能选择传输时长
3. ✅ **提升能量利用**：在合适场景下传输更多能量
4. ✅ **支持信息搭便车**：鼓励携带未上报信息的节点传输更长时间

### 局限

1. ⚠️ **计算开销**：需要遍历多个时长选项（5倍计算量）
2. ⚠️ **参数敏感**：需要根据具体场景调优 `w_aoi` 和 `w_info`
3. ⚠️ **简化模型**：AoI和信息量的影响是简化建模，实际可能更复杂

## 未来扩展

1. **动态时长范围**：根据网络状态动态调整 `min_duration` 和 `max_duration`
2. **更精细的AoI模型**：考虑不同节点的AoI权重差异
3. **信息价值评估**：根据信息的实际价值（而非简单的量）给予奖励
4. **多路径并发传输**：支持同时进行不同时长的传输

## 相关文件

- **调度器实现**：`src/scheduling/schedulers.py` - `DurationAwareLyapunovScheduler`
- **执行器修改**：`src/core/network.py` - `execute_energy_transfer()`
- **信息管理器修改**：`src/acdr/physical_center.py` - `apply_energy_transfer_changes()`
- **配置定义**：`src/config/simulation_config.py` - `SchedulerConfig`
- **测试文件**：`test_duration_aware_scheduler.py`

---

**创建日期**：2024-11-03  
**功能状态**：✅ 已实现并测试通过

