# 无线传感器网络能量传输仿真系统 - 总体说明

## 📋 目录

1. [系统概述](#系统概述)
2. [核心目标](#核心目标)
3. [系统架构](#系统架构)
4. [主要功能模块](#主要功能模块)
5. [工作流程](#工作流程)
6. [关键技术](#关键技术)
7. [应用场景](#应用场景)
8. [技术创新点](#技术创新点)

---

## 📖 系统概述

本系统是一个**无线传感器网络（Wireless Sensor Network, WSN）能量传输仿真平台**，专注于研究和模拟传感器节点之间的**无线能量传输（Wireless Energy Transfer, WET）**过程。

### 研究背景

无线传感器网络广泛应用于环境监测、智能农业、工业物联网等领域，但传感器节点的**能量受限**一直是制约其长期运行的关键瓶颈。本系统通过仿真研究以下核心问题：

1. **如何通过无线能量传输延长网络寿命？**
2. **如何实现网络能量的均衡分布？**
3. **如何优化能量传输策略以提高效率？**
4. **如何设计智能调度算法实现自适应能量管理？**

---

## 🎯 核心目标

### 主要研究目标

1. **能量均衡优化**
   - 避免部分节点过早死亡导致网络功能丧失
   - 实现全网能量的公平分配
   - 延长网络整体寿命

2. **能量传输效率优化**
   - 最小化能量传输损耗
   - 优化多跳传输路径选择
   - 提高能量利用率

3. **智能调度算法研究**
   - 基于优化理论的调度算法（Lyapunov优化）
   - 基于深度强化学习的调度算法（DQN, DDPG）
   - 自适应调度策略

4. **实际应用验证**
   - 模拟真实WSN场景
   - 验证算法有效性
   - 为实际部署提供指导

---

## 🏗️ 系统架构

### 整体架构（分层设计）

```
┌─────────────────────────────────────────────────────────────┐
│                     应用层 (Application Layer)                │
│  • 仿真主程序  • 实验脚本  • 性能评估  • 可视化展示           │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                    算法层 (Algorithm Layer)                   │
│  • 能量调度算法  • 路由协议  • 深度学习模型  • 优化策略      │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                     核心层 (Core Layer)                       │
│  • 传感器节点模型  • 网络拓扑管理  • 能量仿真引擎            │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                    支撑层 (Support Layer)                     │
│  • 配置管理  • 日志记录  • 错误处理  • 性能监控              │
└─────────────────────────────────────────────────────────────┘
```

### 模块组织

```
WSN_ES/
├── src/                          # 源代码
│   ├── config/                   # 配置管理模块
│   ├── core/                     # 核心仿真模块
│   ├── scheduling/               # 调度算法模块
│   ├── routing/                  # 路由协议模块
│   ├── info_collection/          # 信息收集模块
│   ├── sim/                      # 仿真执行模块
│   ├── viz/                      # 可视化模块
│   └── utils/                    # 工具模块
├── tests/                        # 测试脚本
├── docs/                         # 文档
├── data/                         # 仿真数据
└── logs/                         # 运行日志
```

---

## 🔧 主要功能模块

### 1. 网络建模模块 (Core Layer)

#### 功能：构建和管理无线传感器网络

**核心组件：**

- **传感器节点 (SensorNode)**
  - 能量状态管理（当前能量、能量历史）
  - 太阳能采集模拟（基于时间的光照模型）
  - 能量消耗模拟（感知、计算、通信）
  - 移动节点支持（圆形、直线、振荡运动）
  - 位置和通信能力建模

- **网络拓扑 (Network)**
  - 节点分布模式（均匀分布、随机分布、能量空洞）
  - 物理中心节点（高能量汇聚点，不参与WET）
  - 距离矩阵计算（支持GPU加速）
  - 邻居关系维护
  - 能量传输执行引擎

**关键特性：**
```
✓ 支持10-100个节点的网络仿真
✓ 真实的能量采集模型（太阳能节点）
✓ 精确的能量传输效率模型（距离衰减）
✓ 支持单跳和多跳能量传输
✓ GPU加速计算（可选）
```

---

### 2. 能量调度模块 (Scheduling Layer)

#### 功能：决策哪些节点之间进行能量传输，传输多少能量

**支持的调度算法：**

#### 📊 传统优化算法

**1. Lyapunov调度器 (LyapunovScheduler)**
- 基于Lyapunov优化理论
- 目标：最小化能量方差，实现能量均衡
- 特点：理论保证，稳定收敛
- 应用：标准能量均衡场景

**2. 时长感知调度器 (DurationAwareScheduler)**
- 基于Lyapunov优化 + 传输时长优化
- 目标：在能量均衡的同时优化传输效率
- 特点：考虑传输成本，更贴近实际
- 应用：能量受限场景

**3. 自适应时长Lyapunov调度器 (AdaptiveDurationLyapunovScheduler)**
- 基于Lyapunov + 动态传输时长调整
- 目标：自适应调整传输参数
- 特点：根据网络状态动态优化
- 应用：动态变化的网络环境

#### 🤖 深度强化学习算法

**4. DQN调度器 (DQNScheduler)**
- 基于Deep Q-Network深度强化学习
- 动作空间：离散（1-10分钟传输时长）
- 特点：
  - 离散动作，训练稳定
  - 收敛快，计算效率高
  - 适合有限动作空间
- 应用：标准能量调度任务

**5. DDPG调度器 (DDPGScheduler)**
- 基于Deep Deterministic Policy Gradient
- 动作空间：连续（1-10分钟，连续值）
- 特点：
  - 连续动作，精确控制
  - 探索复杂策略
  - 适合高精度需求
- 应用：需要精细控制的场景

**调度决策过程：**
```
每个时间步 t:
  1. 观察网络状态（节点能量、位置等）
  2. 调度器计算传输计划
     - 选择donor节点（能量富余）
     - 选择receiver节点（能量不足）
     - 规划传输路径（单跳或多跳）
     - 决定传输时长（1-10分钟）
  3. 执行能量传输
  4. 更新节点能量状态
  5. 记录传输历史和统计数据
```

---

### 3. 路由协议模块 (Routing Layer)

#### 功能：为能量传输规划最优路径

**支持的路由协议：**

**1. EEOR (Energy-Efficient Opportunistic Routing)**
- **全称**：能量高效机会路由
- **原理**：基于期望代价的多路径机会传输
- **特点**：
  - 考虑链路误码率
  - 能量感知路径选择
  - 自适应邻居发现
- **应用**：数据传输路由

**2. EETOR (Energy-Efficient Transfer Opportunistic Routing)**
- **全称**：能量高效传输机会路由
- **原理**：专为能量传输优化的路由协议
- **特点**：
  - 考虑传输效率衰减
  - 避免效率过低的多跳路径
  - 太阳能节点优先
  - 低能量节点保护
- **应用**：能量传输路由（当前系统主要使用）

**3. ADCR (Adaptive Dynamic Cooperative Routing)**
- **全称**：自适应动态协作路由
- **原理**：基于簇的协作路由
- **特点**：
  - 自适应聚类（估计最优簇数K*）
  - 能量感知簇头选择
  - 协作上报路径规划
- **应用**：分簇网络信息上报

**路径规划流程：**
```
给定: 源节点 source, 目标节点 dest
目标: 找到最优传输路径

步骤:
  1. 构建候选中继节点集合
  2. 计算每个中继节点的转发代价
     - 传输效率 η(d) = η₀ / d^γ
     - 通信能耗 E = E_elec×B + ε×B×d^τ
     - 节点能量状态
  3. 使用动态规划/贪心算法选择最优路径
  4. 验证路径可行性（效率阈值、最大跳数）
  5. 返回路径 [source → relay₁ → relay₂ → ... → dest]
```

---

### 4. 信息收集与管理模块

#### 功能：收集和管理网络节点信息

**主要组件：**

**1. 物理中心节点 (Physical Center)**
- **定义**：网络中的高能量汇聚点（ID=0）
- **作用**：
  - 信息上报目标
  - 不参与能量传输（避免成为瓶颈）
  - 维护全网节点信息表
- **能量**：初始能量远高于普通节点（例如10万焦耳）

**2. 节点信息管理器 (NodeInfoManager)**
- **功能**：
  - 创建和维护InfoNode虚拟信息节点
  - 记录节点能量、位置、时间戳
  - 提供信息查询接口
  - 支持批量更新
- **优势**：
  - 解耦信息传递和能量消耗
  - 统一信息管理接口
  - 支持机会主义信息传递

**3. 路径信息收集器 (PathBasedCollector)**
- **原理**：搭载（Piggyback）机制
- **工作方式**：
  - 能量传输时，沿路径节点顺便上报信息
  - 无需额外通信，零能耗开销
  - 机会主义更新，按需收集
- **核心功能**：
  - **信息去重**：基于 `info_source_nodes` 字段去重，避免重复计算节点信息
  - **动态等待时长上限**：信息量越大，等待时间上限越低，实现自适应上报
- **优势**：
  - 相比ADCR周期性上报，减少通信开销
  - 信息更新更及时
  - 覆盖率高
  - 精确的信息量计算（通过去重机制）

**4. ADCR链路层 (ADCRLinkLayerVirtual)**
- **功能**：
  - 周期性聚类（例如每24小时）
  - 选择簇头（能量感知+空间抑制）
  - 规划簇头到物理中心的上报路径
  - 结算簇内和簇间通信能耗
- **应用**：
  - 分簇网络管理
  - 周期性信息汇聚
  - 能耗精确建模

---

### 5. 智能被动传能系统

#### 功能：根据网络状态智能决策何时触发能量传输

**传统方式 vs 智能被动传能：**

| 特性 | 传统定时传能 | 智能被动传能 |
|------|------------|------------|
| **触发方式** | 固定时间间隔（如每60分钟） | 根据网络状态按需触发 |
| **能量效率** | 可能频繁传输，浪费能量 | 仅在需要时传输，节能30-50% |
| **响应速度** | 固定周期，可能延迟 | 实时监测，快速响应 |
| **能量均衡** | 被动均衡 | 主动优化均衡 |

**决策机制（多维度综合评估）：**

```
每个检查间隔（默认10分钟）:
  
  评估1: 低能量节点比例
    - 统计能量<30%平均能量的节点比例
    - 比例 > 阈值 → 需要传能
  
  评估2: 能量方差
    - 计算全网能量标准差
    - 方差 > 阈值 → 需要传能
  
  评估3: 预测性分析
    - 预测未来N步后的能量状态
    - 预期低能量比例 > 阈值 → 提前传能
  
  评估4: 紧急情况
    - 检查是否有节点濒临死亡（能量<10%）
    - 有紧急节点 → 立即传能
  
  综合决策:
    - 满足任一条件 → 触发能量传输
    - 否则 → 跳过本次传输
```

**三种预设模式：**

1. **快速响应型**（threshold=0.15, variance=0.15）
   - 高灵敏度，快速响应
   - 传能频率较高
   - 适合能量波动大的场景

2. **均衡型**（threshold=0.2, variance=0.2）⭐ 推荐
   - 平衡响应速度和能量效率
   - 适合大多数应用场景

3. **节能型**（threshold=0.25, variance=0.25）
   - 低灵敏度，减少传能
   - 最大化节能
   - 适合能量充足的场景

---

### 6. 配置管理模块

#### 功能：统一管理所有仿真参数

**配置类结构：**

```python
ConfigManager
  ├── NodeConfig              # 节点配置
  │   ├── 能量参数（初始能量、容量、电压）
  │   ├── 采集参数（太阳能采集率、衰减率）
  │   ├── 通信参数（电路能耗、放大器能耗、路径损耗）
  │   └── 移动参数（移动模式、速度、轨迹）
  │
  ├── NetworkConfig           # 网络配置
  │   ├── 节点数量、分布模式
  │   ├── 太阳能节点比例
  │   ├── 区域大小
  │   └── 物理中心节点配置
  │
  ├── SimulationConfig        # 仿真配置
  │   ├── 仿真时长、时间步长
  │   ├── 能量共享开关
  │   ├── 被动模式配置
  │   └── 日志和输出配置
  │
  ├── SchedulerConfig         # 调度器配置
  │   ├── 调度器类型选择
  │   ├── Lyapunov参数（V, K）
  │   ├── DQN/DDPG参数（学习率、探索率）
  │   └── 动作空间配置
  │
  ├── RoutingConfig           # 路由配置
  │   ├── 最大跳数
  │   ├── 效率阈值
  │   └── 邻居发现参数
  │
  └── ADCRConfig              # ADCR配置
      ├── 聚类周期
      ├── 簇头选择参数
      ├── 数据聚合参数
      └── 能耗结算开关
```

**配置方式：**
1. **代码配置**：直接在Python代码中设置参数
2. **JSON配置文件**：使用JSON文件配置（支持加载和保存）
3. **命令行参数**：通过命令行传递配置参数
4. **默认配置**：使用系统预设的默认值

---

### 7. 可视化与分析模块

#### 功能：可视化仿真结果，分析系统性能

**可视化内容：**

1. **网络拓扑图**
   - 节点位置分布
   - 太阳能节点标识
   - 物理中心节点标识
   - 实时能量状态（颜色编码）

2. **能量传输路径图**
   - 传输路径可视化
   - 多跳路径展示
   - 传输能量和损耗标注

3. **能量时序图**
   - 节点能量随时间变化
   - 平均能量趋势
   - 能量方差变化

4. **性能统计图**
   - K值动态调整曲线（如启用动态K）
   - 传输次数统计
   - 能量损耗分析
   - 传输效率分布

5. **ADCR聚类可视化**
   - 簇结构展示
   - 簇头节点标识
   - 上报路径可视化

**输出格式：**
- PNG/JPG图片
- 交互式HTML（Plotly）
- CSV数据表
- 日志文件

---

## 🔄 工作流程

### 完整仿真流程

```
┌──────────────────────────────────────────────────────────────┐
│  1. 初始化阶段                                                 │
├──────────────────────────────────────────────────────────────┤
│  • 加载配置文件                                                │
│  • 创建传感器网络（节点分布、初始能量）                          │
│  • 初始化物理中心节点                                           │
│  • 创建调度器（选择算法）                                       │
│  • 创建路由器（EETOR/EEOR）                                    │
│  • 初始化信息管理器                                             │
│  • 创建ADCR链路层（可选）                                       │
│  • 创建可视化模块                                               │
└──────────────────────────────────────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────┐
│  2. 仿真主循环（每个时间步）                                    │
├──────────────────────────────────────────────────────────────┤
│  for t = 0 to T_max:                                         │
│                                                              │
│    2.1 能量更新阶段                                            │
│      • 太阳能节点能量采集                                       │
│      • 所有节点能量衰减                                         │
│      • 所有节点感知能耗                                         │
│      • 移动节点位置更新（如启用）                                │
│                                                              │
│    2.2 信息收集阶段（可选）                                     │
│      • ADCR周期性聚类和上报（满足周期条件时）                    │
│      • 路径信息收集器更新（传能时搭载）                          │
│                                                              │
│    2.3 能量传输决策阶段                                        │
│      • 智能被动传能系统评估是否需要传能                          │
│      • 如果需要：                                              │
│        ├─ 调度器观察网络状态                                    │
│        ├─ 选择donor和receiver节点                             │
│        ├─ 使用路由协议规划传输路径                               │
│        ├─ 决定传输时长（1-10分钟）                              │
│        └─ 生成传输计划列表                                      │
│                                                              │
│    2.4 能量传输执行阶段                                        │
│      • 遍历所有传输计划                                         │
│      • 逐跳执行能量传输：                                       │
│        ├─ 计算传输效率 η(d) = η₀ / d^γ                        │
│        ├─ 计算传输能量和损耗                                    │
│        ├─ 计算通信能耗（发送端和接收端）                         │
│        ├─ 更新节点能量状态                                      │
│        └─ 记录传输历史                                          │
│                                                              │
│    2.5 深度学习训练阶段（如启用DQN/DDPG训练模式）                │
│      • 记录状态-动作-奖励转移                                   │
│      • 存储到经验回放缓冲区                                      │
│      • 采样批次数据训练神经网络                                  │
│      • 更新Q网络/Actor-Critic网络                              │
│      • 探索率衰减                                               │
│                                                              │
│    2.6 统计和记录阶段                                          │
│      • 记录节点能量状态                                         │
│      • 统计传输次数和能量                                       │
│      • 计算性能指标（能量方差、死亡节点数）                       │
│      • 更新可视化数据                                           │
│      • 写入日志文件                                             │
│                                                              │
│    2.7 终止条件检查                                            │
│      • 是否达到最大时间步？                                     │
│      • 是否有节点死亡（能量耗尽）？                              │
│      • 是否满足自定义终止条件？                                  │
│                                                              │
└──────────────────────────────────────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────┐
│  3. 结果分析阶段                                               │
├──────────────────────────────────────────────────────────────┤
│  • 生成性能统计报告                                             │
│  • 绘制可视化图表                                               │
│  • 保存仿真数据（CSV/JSON）                                     │
│  • 保存训练好的模型（DQN/DDPG）                                 │
│  • 生成日志文件                                                 │
│  • 计算关键指标：                                               │
│    ├─ 网络寿命（首个节点死亡时间）                               │
│    ├─ 平均能量方差                                              │
│    ├─ 总能量损耗                                                │
│    ├─ 传输效率                                                  │
│    └─ 能量分布均匀度（变异系数CV）                               │
└──────────────────────────────────────────────────────────────┘
```

### 典型应用流程示例

#### 场景1: 标准能量均衡仿真

```bash
# 1. 配置仿真参数
# 编辑 simulation_config.py 或使用默认配置

# 2. 运行仿真（使用Lyapunov调度器 + 智能被动传能）
python src/sim/refactored_main.py

# 3. 查看结果
# - 日志: logs/YYYYMMDD/simulation.log
# - 数据: data/YYYYMMDD_HHMMSS/
# - 图表: 自动生成在data目录
```

#### 场景2: DQN深度学习调度器训练

```bash
# 1. 训练DQN模型（50回合，约2小时）
# 在 simulation_config.py 中设置:
#   enable_dqn = True
#   dqn_training_mode = True
#   dqn_training_episodes = 50

python src/sim/refactored_main.py

# 2. 使用训练好的模型进行推理
# 修改配置:
#   dqn_training_mode = False

python src/sim/refactored_main.py

# 3. 模型文件保存在: dqn_model.pth
```

#### 场景3: 对比实验（并行仿真）

```bash
# 对比不同调度器性能
python src/sim/parallel_executor.py \
  --scheduler lyapunov duration_aware dqn \
  --runs 10 \
  --processes 4

# 结果自动生成对比报告
```

---

## 🔑 关键技术

### 1. 能量传输模型

#### 传输效率模型
```
η(d) = η₀ / d^γ

其中:
  η(d) - 距离d时的传输效率
  η₀   - 基准效率（通常0.6-0.8）
  d    - 传输距离（米）
  γ    - 路径损耗指数（通常2-4）
```

**多跳传输效率**：
```
η_path = ∏(i=1 to n-1) η(d_i)

多跳传输会导致效率急剧下降，因此系统优先单跳传输
```

#### 通信能耗模型
```
发送能耗: E_tx = E_elec × B + ε_amp × B × d^τ
接收能耗: E_rx = E_elec × B

其中:
  E_elec - 电路能耗（J/bit）
  B      - 数据包大小（bits）
  ε_amp  - 放大器能耗（J/bit/m^τ）
  d      - 传输距离（米）
  τ      - 路径损耗指数
```

### 2. Lyapunov优化理论

**目标**：最小化能量方差，实现能量均衡

**Lyapunov函数**：
```
L(E) = Σ(E_i - E_bar)²

其中:
  E_i   - 节点i的当前能量
  E_bar - 全网平均能量
```

**优化目标**：
```
min ΔL = L(t+1) - L(t)

通过选择合适的传输计划，使Lyapunov函数下降
```

**传输评分函数**：
```
score = Q(receiver) × delivered - V × loss

其中:
  Q(receiver) = E_bar - E_receiver  (能量缺口)
  delivered   - 接收能量
  loss        - 传输损耗
  V           - 权重参数（平衡均衡性和效率）
```

### 3. 深度强化学习（DQN/DDPG）

#### 马尔可夫决策过程（MDP）建模

**状态空间 S**：
```
S_t = [E_1, E_2, ..., E_n,        # 各节点归一化能量
       E_mean,                     # 平均能量
       E_std,                      # 能量标准差
       E_min,                      # 最小能量
       low_energy_ratio,           # 低能量节点比例
       t_normalized]               # 归一化时间步
```

**动作空间 A**：
```
DQN:  A = {1, 2, 3, ..., 10}      # 离散动作（传输时长1-10分钟）
DDPG: A ∈ [1.0, 10.0]             # 连续动作（传输时长1-10分钟）
```

**奖励函数 R**：
```
R_t = R_balance + R_efficiency + R_penalty

其中:
  R_balance    = (σ_prev - σ_curr) × 10     # 能量均衡改善
  R_efficiency = η × 2                      # 传输效率
  R_penalty    = -low_ratio × 5 - dead × 20 # 低能量/死亡惩罚
```

#### DQN算法
- Q网络：估计状态-动作值函数 Q(s, a)
- 目标网络：稳定训练目标
- 经验回放：打破数据相关性
- ε-greedy探索：平衡探索与利用

#### DDPG算法
- Actor网络：策略函数 μ(s)
- Critic网络：Q值函数 Q(s, a)
- 目标网络：Actor和Critic各有目标网络
- OU噪声：连续动作空间探索

### 4. 信息去重与动态等待机制

#### 信息去重技术

**问题背景**：
在多路径信息收集场景中，同一节点的信息可能被多次计算，导致信息量错误累积。

**解决方案**：
```python
# 基于 info_source_nodes 字段去重
existing_source_nodes = set(node_info.get('info_source_nodes', []))
path_node_ids = set([node.node_id for node in path])
new_node_ids = path_node_ids - existing_source_nodes

# 只计算新节点的信息量
new_info_volume = base_data_size × len(new_node_ids)
```

**关键特性**：
- 使用 `info_source_nodes` 集合记录已收集信息的节点
- 新路径到达时，仅计算不在已有集合中的节点信息
- 避免重复累积，确保信息量准确

**效果**：
- 准确计算信息量，避免重复计数
- 优化信息上报决策的准确性

#### 动态等待时长上限

**原理**：
根据累积的信息量动态调整等待时间上限，实现自适应信息上报。

**自适应公式**：
```
adaptive_max_wait_time = max_wait_time / (1 + info_volume / scale_factor)
```

**工作机制**：
1. **信息量小时**：等待时间上限接近 `max_wait_time`，允许更长等待以收集更多信息
2. **信息量增大时**：等待时间上限逐渐降低，促进及时上报
3. **信息量很大时**：等待时间上限接近最小值（1分钟），确保信息不会积压过久

**配置参数**：
```python
enable_adaptive_wait_time: bool = True      # 是否启用自适应等待
max_wait_time: int = 500                    # 基础最大等待时间（分钟）
wait_time_scale_factor: float = None        # 缩放因子（自动计算）
```

**优势**：
- 信息量少时允许等待，减少上报次数和能耗
- 信息量多时及时上报，避免信息积压
- 动态平衡信息新鲜度与通信开销

### 5. GPU加速技术

**加速内容**：
- 距离矩阵计算（O(n²)复杂度）
- 大规模矩阵运算
- 并行化数值计算

**实现方式**：
```python
# 使用CuPy替代NumPy
if cupy_available:
    distances = cp.sqrt(cp.sum((positions[:, None] - positions) ** 2, axis=2))
else:
    distances = np.sqrt(np.sum((positions[:, None] - positions) ** 2, axis=2))
```

**性能提升**：
- 100节点网络：约2-3倍加速
- 1000节点网络：约5-10倍加速

---

## 🎯 应用场景

### 1. 环境监测网络
- **场景**：森林火灾监测、空气质量监测
- **特点**：节点分布广泛，部分节点难以更换电池
- **应用**：通过能量传输延长偏远节点寿命

### 2. 智能农业
- **场景**：农田温湿度监测、土壤监测
- **特点**：部分节点有太阳能，部分节点阴影区域
- **应用**：太阳能节点向阴影区域节点传输能量

### 3. 工业物联网
- **场景**：工厂设备监测、仓库环境监测
- **特点**：节点密集，能量需求不均
- **应用**：高能量节点向传感器密集区域传能

### 4. 智慧城市
- **场景**：路灯、交通监测、环境监测
- **特点**：部分节点有市电，部分节点电池供电
- **应用**：市电节点向电池节点无线传能

### 5. 医疗健康
- **场景**：可穿戴设备网络、医院环境监测
- **特点**：节点能量受限，需要频繁充电
- **应用**：充电站向附近设备无线传能

---

## 💡 技术创新点

### 1. 智能被动传能系统 ⭐
**创新点**：根据网络状态按需触发能量传输
- 相比传统定时传能，节能30-50%
- 多维度综合决策机制
- 预测性传能，提前防止节点死亡

### 2. 深度强化学习调度器 ⭐
**创新点**：使用DQN/DDPG学习最优调度策略
- 端到端学习，无需手工设计规则
- 自适应网络状态变化
- 支持连续和离散动作空间

### 3. 机会主义信息传递 ⭐
**创新点**：能量传输时搭载节点信息
- 零能耗开销（相比ADCR周期上报）
- 信息更新及时
- 覆盖率高

### 4. 虚拟信息节点（InfoNode）⭐
**创新点**：解耦信息传递和能量消耗
- 统一信息管理接口
- 支持历史信息查询
- 支持异步信息更新

### 5. 能量传输专用路由（EETOR）⭐
**创新点**：专为能量传输优化的路由协议
- 考虑传输效率衰减模型
- 避免效率过低的多跳路径
- 太阳能节点和低能量节点感知

### 6. 自适应时长调度 ⭐
**创新点**：动态调整传输时长
- 根据节点能量状态优化时长
- 平衡传输效率和能量消耗
- DQN/DDPG自动学习最优时长

### 7. GPU加速仿真 ⭐
**创新点**：利用GPU加速大规模网络仿真
- 支持100+节点实时仿真
- 距离矩阵计算加速5-10倍
- 深度学习训练加速

### 8. 物理中心节点架构 ⭐
**创新点**：引入高能量物理中心节点
- 不参与能量传输，避免瓶颈
- 作为信息汇聚点
- 简化系统架构

### 9. 信息去重机制 ⭐
**创新点**：精确的信息量计算
- 基于 `info_source_nodes` 集合避免重复计数
- 多路径场景下准确累积信息量
- 确保信息上报决策的准确性
- 支持复杂的搭便车场景

### 10. 动态等待时长上限 ⭐
**创新点**：自适应信息上报策略
- 根据信息量动态调整等待时间
- 信息量少时延长等待，减少通信开销
- 信息量多时缩短等待，保证信息新鲜度
- 平衡信息时效性与能量效率

---

## 📊 系统性能指标

### 关键性能指标（KPI）

1. **网络寿命**
   - 定义：首个节点死亡时间
   - 目标：最大化网络寿命
   - 典型值：1000-10000分钟（约1-7天）

2. **能量均衡度**
   - 定义：能量变异系数 CV = σ / μ
   - 目标：最小化能量方差
   - 典型值：CV < 0.2（良好均衡）

3. **能量利用效率**
   - 定义：有效传输能量 / 总消耗能量
   - 目标：最大化能量效率
   - 典型值：60-85%

4. **传输效率**
   - 定义：接收能量 / 发送能量
   - 目标：减少传输损耗
   - 典型值：单跳70-90%，多跳20-60%

5. **节点死亡率**
   - 定义：死亡节点数 / 总节点数
   - 目标：最小化节点死亡
   - 典型值：0-20%

### 性能基准

| 调度器 | 网络寿命 | 能量CV | 能量效率 | 传输次数 |
|--------|---------|--------|---------|---------|
| **无能量共享** | 1000分钟 | 0.35 | N/A | 0 |
| **Lyapunov** | 5000分钟 | 0.15 | 75% | 200 |
| **DurationAware** | 5500分钟 | 0.18 | 78% | 180 |
| **DQN** | 5800分钟 | 0.14 | 80% | 150 |
| **DDPG** | 6000分钟 | 0.13 | 82% | 140 |

*注：以上数据为15节点网络、7天仿真的典型结果*

---

## 🚀 快速开始

### 环境要求
```
Python >= 3.8
NumPy >= 1.19
Matplotlib >= 3.3
Plotly >= 5.0
Pandas >= 1.2
PyTorch >= 1.9 (如使用DQN/DDPG)
CuPy (可选，GPU加速)
```

### 安装依赖
```bash
pip install -r requirements.txt
```

### 运行标准仿真
```bash
# 使用默认配置（Lyapunov + 智能被动传能）
python src/sim/refactored_main.py

# 使用DQN调度器
python src/sim/refactored_main.py --scheduler dqn

# 查看帮助
python src/sim/refactored_main.py --help
```

### 训练DQN模型
```bash
# 训练50回合（约2小时）
python tests/run_dqn_simulation.py --train --episodes 50

# 测试训练好的模型
python tests/run_dqn_simulation.py --test
```

### 运行并行实验
```bash
# 对比不同调度器
python src/sim/parallel_executor.py \
  --schedulers lyapunov dqn ddpg \
  --runs 10
```

---

## 📚 相关文档

### 核心文档
- [快速启动指南](./快速启动指南.md)
- [DQN训练和使用完整指南](./DQN训练和使用完整指南.md)
- [智能被动传能系统说明](./智能被动传能系统说明.md)

### 算法文档
- [Lyapunov调度器原理](./深度学习调度器对比.md)
- [DQN离散动作调度器说明](./DQN离散动作调度器说明.md)
- [DDPG深度强化学习调度器说明](./DDPG深度强化学习调度器说明.md)
- [EEOR路由算法详细逻辑说明](./EEOR路由算法详细逻辑说明.md)
- [EETOR路由算法逻辑说明](./EETOR路由算法逻辑说明.md)

### 技术文档
- [机会主义信息传递机制设计](./机会主义信息传递机制设计.md)
- [路径信息收集器使用说明](./路径信息收集器使用说明.md)
- [信息去重功能分析与实现方案](./信息去重功能分析与实现方案.md)
- [物理中心节点改造总结](./物理中心节点改造总结.md)
- [GPU加速使用指南](./GPU加速使用指南.md)

### 问题解决
- [DQN传能过频问题修复指南](./DQN传能过频问题修复指南.md)
- [DQN训练损失修复说明](./DQN训练损失修复说明.md)
- [DQN测试模式被动传能配置说明](./docs/DQN测试模式被动传能配置说明.md) ⭐ 新增

---

## 🤝 贡献指南

欢迎贡献代码、报告问题或提出建议！

### 贡献方式
1. Fork 项目
2. 创建特性分支 (`git checkout -b feature/AmazingFeature`)
3. 提交更改 (`git commit -m 'Add some AmazingFeature'`)
4. 推送到分支 (`git push origin feature/AmazingFeature`)
5. 打开 Pull Request

### 开发规范
- 遵循PEP 8代码规范
- 添加必要的注释和文档
- 编写单元测试
- 更新相关文档

---

## 📄 许可证

本项目采用 MIT 许可证。详见 [LICENSE](../LICENSE) 文件。

---

## 📧 联系方式

如有问题或建议，请：
- 提交 GitHub Issue
- 发送邮件
- 参与讨论

---

## 🙏 致谢

感谢所有为本项目做出贡献的开发者和研究者！

---

**最后更新时间**：2025-11-05

**文档版本**：v1.1

**更新内容**：
- 新增信息去重机制说明
- 新增动态等待时长上限机制说明
- 更新技术创新点列表

