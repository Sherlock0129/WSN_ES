# 指令下发能量计算功能实现报告

## ✅ 实现目标

**核心需求**: 实现物理中心节点向参与传能的节点下发指令的能量计算，确保分布式控制模型的完整性。

**实现方案**: 方案1（能量计账） - 简单有效，只计算能量开销而不模拟完整通信过程

---

## 📋 实现内容

### **1. 配置项** (`src/config/simulation_config.py`)

在`SimulationConfig`中新增：

```python
# 指令下发能量计算
enable_command_downlink: bool = True  # 是否启用指令下发能量计算（物理中心→节点）
command_packet_size: int = 1          # 指令包大小（B，与base_data_size相同）
```

**说明**：
- 默认启用指令下发能量计算
- 指令包大小统一为1B，与节点间通信数据包相同
- 可通过配置灵活开关

---

### **2. 能量计算方法** (`src/core/energy_simulation.py`)

#### **新增参数**

```python
def __init__(self, network, time_steps, scheduler=None,
             # ... 其他参数 ...
             # 指令下发参数
             enable_command_downlink=True,  # 是否启用指令下发能量计算
             command_packet_size=1):  # 指令包大小（B）
```

#### **核心方法**: `calculate_command_downlink_energy(physical_center, plans)`

```python
def calculate_command_downlink_energy(self, physical_center, plans):
    """
    计算指令下发的能量消耗
    
    物理中心需要向所有参与传能的节点下发指令，告知它们执行传能计划。
    每个节点（donor、receiver、relay）都会收到一个固定大小的指令包。
    
    能量计算：
    - 中心发送：E_tx = center.energy_consumption(node, command_size, transfer_WET=False)
    - 节点接收：E_rx = node.energy_consumption(center, command_size, transfer_WET=False)
    - 双向扣除：center.current_energy -= E_tx, node.current_energy -= E_rx
    
    :param physical_center: 物理中心节点
    :param plans: 传能计划列表
    :return: (total_energy, success) - 总能量消耗和是否成功
    """
```

**功能特性**：

1. **节点去重**: 自动去重，同一节点在多个plan中只计算一次
2. **双向扣除**: 
   - 中心发送能量（E_tx）
   - 节点接收能量（E_rx）
   - 同时扣除两者的能量
3. **能量检查**: 中心能量不足时返回失败，取消本轮传能
4. **固定包大小**: 所有指令包统一为1B（`command_packet_size`）

---

### **3. 执行流程集成**

在`simulate()`方法的传能计划执行之前插入指令下发：

```python
# 生成传能计划
result = self.scheduler.plan(self.network, t)
if isinstance(result, tuple):
    plans, cand = result
else:
    plans = result

# 计算并扣除指令下发能量
physical_center = self.network.get_physical_center()
command_energy, can_execute = self.calculate_command_downlink_energy(physical_center, plans)

# 只有指令下发成功才执行传能计划
if can_execute:
    # 执行传能
    self.network.execute_energy_transfer(plans, current_time=t)
else:
    # 指令下发失败，取消传能计划
    plans = []
    print("[指令下发] 警告：物理中心能量不足，本轮传能取消")
```

---

### **4. 参数传递** (`src/config/simulation_config.py`)

在`ConfigManager.create_energy_simulation()`中传递参数：

```python
def create_energy_simulation(self, network, scheduler=None):
    return EnergySimulation(
        # ... 其他参数 ...
        # 指令下发参数
        enable_command_downlink=self.simulation_config.enable_command_downlink,
        command_packet_size=self.simulation_config.command_packet_size
    )
```

---

## 🔍 算法细节

### **节点收集**

```python
# 收集所有需要通知的节点（去重）
notified_nodes = set()
for plan in plans:
    # donor和receiver
    notified_nodes.add(plan['donor'])
    notified_nodes.add(plan['receiver'])
    # 中继节点（path中除了起点和终点的节点）
    if 'path' in plan and len(plan['path']) > 2:
        for node in plan['path'][1:-1]:
            notified_nodes.add(node)
```

**示例**：
```
Plan 1: Node1 → Node2
Plan 2: Node3 → Node2 (Node2重复)
Plan 3: Node4 → Node1 → Node5 (Node1作为中继)

去重后通知节点: {Node1, Node2, Node3, Node4, Node5} (5个)
```

### **能量计算**

```python
for node in notified_nodes:
    # 临时设置数据包大小为command_size_bytes
    physical_center.B = command_size_bytes
    node.B = command_size_bytes
    
    # 计算中心发送能量
    E_tx = physical_center.energy_consumption(
        target_node=node,
        transfer_WET=False
    )
    
    # 计算节点接收能量
    E_rx = node.energy_consumption(
        target_node=physical_center,
        transfer_WET=False
    )
    
    # 累加能量
    center_energy_cost += E_tx
    total_energy += (E_tx + E_rx)
```

### **能量扣除**

```python
# 检查中心能量是否足够
if physical_center.current_energy < center_energy_cost:
    print("[指令下发] 警告：物理中心能量不足！")
    print(f"  - 需要能量: {center_energy_cost:.2f}J")
    print(f"  - 当前能量: {physical_center.current_energy:.2f}J")
    print(f"  - 本轮传能取消")
    return 0.0, False

# 扣除中心能量
physical_center.current_energy -= center_energy_cost

# 扣除各节点的接收能量
for node in notified_nodes:
    E_rx = node.energy_consumption(physical_center, command_size_bytes)
    node.current_energy = max(0.0, node.current_energy - E_rx)
```

---

## ✅ 测试验证

### **测试1: 配置项传递**
- [OK] `enable_command_downlink`默认为`True`
- [OK] `command_packet_size`默认为`1 B`
- [OK] 配置正确传递到`EnergySimulation`

### **测试2: 指令下发能量计算**
- [OK] 正确收集所有参与节点
- [OK] 正确计算E_tx和E_rx
- [OK] 双向扣除能量（中心和节点）
- [OK] 节点能量确实被扣除

### **测试3: 中心能量不足时取消传能**
- [OK] 中心能量不足时返回`success=False`
- [OK] 传能计划被正确取消

### **测试4: 节点去重功能**
- [OK] 同一节点在多个plan中只计算一次
- [OK] 测试场景：5个不同节点，正确去重

**测试结果**: 所有测试通过

---

## 📊 能量开销分析

### **典型场景估算**

假设：
- 30节点网络
- 每轮生成10条传能计划
- 每条plan平均涉及3个节点（donor, receiver, 1个relay）
- 指令包大小：1B = 8bits
- 平均通信距离：50m

**每轮指令下发能量**：
```
去重后节点数: ~15-20个节点

单次通信能量（估算）:
E_tx ≈ E_elec × bits + ε_amp × bits × d^2
E_tx ≈ 1e-4 × 8 + 1e-5 × 8 × 50^2
E_tx ≈ 0.0008 + 0.2 = 0.2008 J

E_rx ≈ E_elec × bits
E_rx ≈ 1e-4 × 8 = 0.0008 J

双向能量 ≈ 0.2016 J/节点

总能量/轮 ≈ 0.2016 × 18 ≈ 3.6 J
```

**长期影响**：
```
仿真时长: 10080分钟 (7天)
传能间隔: 60分钟
总轮数: 168轮

累计指令下发能量 ≈ 3.6 × 168 ≈ 605 J

相比物理中心初始能量（400000 J）：
605 / 400000 ≈ 0.15%
```

**结论**: 指令下发能量开销相对较小但累积可观，长期运行会影响中心能量。

---

## 🎯 实现特性

### **优点** ✅
1. **简单高效**: 只计算能量，不模拟复杂通信过程
2. **双向计账**: 真实反映通信能量消耗（发送+接收）
3. **灵活配置**: 可通过配置开关
4. **自动去重**: 避免重复计算
5. **失败保护**: 能量不足时自动取消传能
6. **兼容性好**: 不改变现有执行流程

### **局限** ⚠️
1. **不模拟延迟**: 假设指令瞬间到达
2. **不考虑丢包**: 假设通信100%成功
3. **不模拟队列**: 假设节点立即处理指令
4. **统一包大小**: 所有节点收到相同大小指令

这些局限符合方案1的设计目标（简化模型），未来可通过方案2/3扩展。

---

## 📂 修改文件汇总

### **核心代码** (2个文件)
1. **`src/config/simulation_config.py`**
   - 新增配置项：`enable_command_downlink`, `command_packet_size`
   - 新增参数传递逻辑

2. **`src/core/energy_simulation.py`**
   - 新增方法：`calculate_command_downlink_energy()`
   - 新增参数：`enable_command_downlink`, `command_packet_size`
   - 集成指令下发到执行流程

### **代码统计**
- **新增代码**: ~130行
- **修改代码**: ~20行
- **总计**: ~150行

---

## 🔄 使用方式

### **默认启用**
```python
# 使用默认配置（已启用指令下发）
config = ConfigManager()
simulation = config.create_energy_simulation(network, scheduler)
simulation.simulate()  # 自动计算指令下发能量
```

### **关闭指令下发**
```python
# 在配置文件中设置
{
    "simulation": {
        "enable_command_downlink": false
    }
}
```

或代码中：
```python
config.simulation_config.enable_command_downlink = False
```

### **自定义包大小**
```python
config.simulation_config.command_packet_size = 2  # 2字节
```

---

## 📝 下一步扩展

如需实现更完整的分布式控制模型（方案2/3），可以扩展：

1. **指令内容建模**
   - 定义指令数据结构
   - 包含路径信息、角色信息、能量值等

2. **传输延迟模拟**
   - 基于距离计算延迟
   - 节点状态可能在延迟期间改变

3. **丢包处理**
   - 通信失败概率
   - 重传机制

4. **队列管理**
   - 节点指令队列
   - 并发执行多个plan

5. **确认机制**
   - 节点收到指令后发送ACK
   - 中心确认后才开始传能

---

**实现完成时间**: 2025年10月28日  
**测试结果**: 所有测试通过  
**功能状态**: 生产就绪

---

## 🎉 总结

成功实现了**方案1（能量计账）**的指令下发功能：

- ✅ 配置灵活（可开关、可调整包大小）
- ✅ 双向能量扣除（中心E_tx + 节点E_rx）
- ✅ 自动节点去重
- ✅ 能量不足保护
- ✅ 所有测试通过
- ✅ 代码简洁高效

该实现为完整的分布式控制模型奠定了基础，未来可根据需要逐步扩展为更复杂的通信模型。

---

## 📋 架构重构（2025-10-28）

### 重构背景

原始实现中，指令下发逻辑完全在 `EnergySimulation` 类中实现，导致职责分配不够清晰。`NodeInfoManager`（物理中心）只负责被动接收信息，缺乏主动行为。

### 重构目标

将指令下发功能从 `EnergySimulation` 迁移到 `NodeInfoManager` 类，实现更清晰的职责分离和更好的面向对象设计。

### 重构内容

#### 1. NodeInfoManager 新增方法

- **`_collect_command_recipients(plans)`**: 收集需要接收指令的节点
- **`_execute_broadcast(physical_center_node, notified_nodes, command_packet_size)`**: 执行指令广播并扣除能量
- **`broadcast_commands(physical_center_node, plans, command_packet_size=1)`**: 物理中心向参与节点广播执行指令（公开接口）

#### 2. EnergySimulation 重构

- **`calculate_command_downlink_energy(physical_center, plans)`**: 简化为委托给 NodeInfoManager 执行

### 重构优势

| 方面 | 重构前 | 重构后 |
|------|--------|--------|
| 职责分配 | EnergySimulation负责一切 | NodeInfoManager负责指令，Simulation负责调度 |
| 封装性 | 较差（逻辑分散） | 好（集中在NodeInfoManager） |
| 可读性 | 一般 | 强（`nim.broadcast_commands`很直观） |
| 可测试性 | 一般 | 好（可以独立测试broadcast） |
| 代码复用 | 差 | 好（其他地方也能用broadcast） |
| OOP原则 | 违反单一职责 | 符合单一职责、高内聚低耦合 |

### 重构结果

- ✅ 所有测试通过（包括独立测试、委托测试）
- ✅ 代码更加简洁（删除了不必要的兼容方法）
- ✅ 架构更加清晰合理
- ✅ 符合面向对象设计原则

详细信息请参考：**[指令下发重构报告.md](./指令下发重构报告.md)**

