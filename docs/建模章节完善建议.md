# 建模章节完善建议

基于代码分析，以下是建议补充到"建模"章节的内容，以及可以作为其他methodology小节的内容。

## 一、建模章节（Modeling）可以补充的内容

### 1. **通信能耗模型的详细量化**

**建议位置**：在能量传输机制部分之后

**内容补充**：
```
The communication energy consumption follows a well-established radio energy model to simulate realistic wireless communication costs. For each data transmission between nodes, the energy consumption consists of three components: (1) Transmitter energy: E_tx = E_elec × B + ε_amp × B × d^τ, where E_elec is the electronics energy per bit, B is the data packet size in bits, ε_amp is the amplifier coefficient, d is the transmission distance, and τ is the path loss exponent (typically 2.0); (2) Receiver energy: E_rx = E_elec × B for processing received packets; (3) Fixed sensor energy consumption: E_sen = 0.1 J per time step. The total communication cost is calculated as E_com = (E_tx + E_rx)/2 + E_sen, where the division by 2 accounts for the averaged bidirectional communication overhead (including ACK acknowledgment). Additionally, when a node performs wireless energy transfer (WET), an extra overhead E_char (typically 500-1000 J) is added to account for the charging circuit energy consumption. This comprehensive energy model ensures that the simulation accurately captures both data communication and energy transfer overheads, providing a realistic energy accounting mechanism for evaluating different energy cooperation strategies.
```

**代码依据**：
- `src/core/SensorNode.py` lines 195-221 (energy_consumption方法)
- `src/config/simulation_config.py` lines 32-70 (NodeConfig中的能耗参数)

---

### 2. **节点异质性模型的扩展**

**建议位置**：在节点属性部分（60%太阳能、40%电池、10%移动）之后

**内容补充**：
```
To capture more realistic network scenarios, the model incorporates additional heterogeneity dimensions beyond energy harvesting and mobility. Specifically, nodes can be configured with spatial energy distribution patterns: a "center-decreasing" mode assigns higher initial energy to nodes near the network geometric center (e.g., 40,000 J) and lower energy to edge nodes (e.g., 30,000 J), simulating scenarios where central nodes experience higher traffic loads or deployment disparities. Additionally, a special physical center node (ID=0) can be enabled to represent a data sink or base station with significantly higher energy capacity (typically 10× that of regular nodes) and is excluded from energy transfer operations. The model also supports an "energy hole" distribution pattern, where non-solar nodes (the 40% battery-only nodes) are spatially clustered around a designated center point (random, corner, or geometric center), creating localized energy depletion zones that mimic real-world deployment challenges. These heterogeneous configurations enable comprehensive evaluation of energy cooperation strategies under diverse network conditions.
```

**代码依据**：
- `src/core/network.py` lines 39-41, 100-107 (能量分配模式)
- `src/core/network.py` lines 33-35, 93-95, 315-398 (能量空洞模式)
- `src/core/network.py` lines 57-58, 403-454 (物理中心节点)

---

### 3. **太阳能采集的时间依赖性模型**

**建议位置**：在能量演化模型部分

**内容补充**：
```
Solar energy harvesting for eligible nodes follows a time-dependent sinusoidal model that simulates realistic daily illumination patterns. The solar irradiance G(t) at time t (in minutes, 0-1440 per day) is calculated as: G(t) = G_max × sin(π × (t - 360) / 720) for t ∈ [360, 1080] (6:00 AM to 6:00 PM), and G(t) = 0 otherwise, where G_max is the peak solar irradiance (typically 1500 W/m²). The actual harvested energy per time step is then: E_harvest = η_solar × A_solar × G(t) × F_env, where η_solar is the photovoltaic conversion efficiency (typically 0.2), A_solar is the solar panel area (0.1 m²), and F_env is an environmental correction factor accounting for weather conditions or partial shading (default 1.0). This temporal model captures the cyclic nature of solar energy availability and enables evaluation of energy cooperation strategies under varying energy supply conditions throughout the day.
```

**代码依据**：
- `src/core/SensorNode.py` lines 144-169 (solar_irradiance和energy_harvest方法)

---

### 4. **无线能量传输效率的衰减模型**

**建议位置**：在能量传输机制部分（多跳路由之前）

**内容补充**：
```
The wireless energy transfer (WET) efficiency η(d) between two nodes separated by distance d follows an exponential decay model to reflect realistic near-field or mid-field energy transfer characteristics. Specifically, when d ≤ 1.0 m, the efficiency uses a linear interpolation: η(d) = η_0 + (1.0 - η_0) × (1.0 - d), ensuring smooth behavior at short distances. For d > 1.0 m, the efficiency follows an inverse power-law decay: η(d) = η_0 / (d^γ), where η_0 is the reference efficiency at 1 m (typically 0.6) and γ is the decay exponent (typically 2.0). The efficiency is clamped to the range [0, 1] to ensure physical realizability. For multi-hop energy transfers, the end-to-end efficiency is the product of all individual hop efficiencies: η_path = ∏ᵢ η(dᵢ), capturing the multiplicative energy loss in multi-hop routing scenarios. This efficiency model is integrated into the scheduling algorithm's path selection, favoring shorter paths and better-aligned routes for energy-efficient transfers.
```

**代码依据**：
- `src/core/SensorNode.py` lines 223-244 (energy_transfer_efficiency方法)

---

### 5. **节点移动性模型**

**建议位置**：在节点属性部分（10%移动节点之后）

**内容补充**：
```
Mobile nodes follow predefined mobility patterns to simulate realistic network dynamics while maintaining controlled experimental conditions. The model supports three mobility patterns: (1) Circular trajectory: nodes move along circular paths centered at their initial deployment positions with user-defined radius (typically 1.0 m) and angular speed (typically 0.01 radians per time step), suitable for simulating constrained movements in industrial environments; (2) Linear movement: nodes move along straight lines in a specified direction [dx, dy] with constant speed (typically 0.1 m/step), modeling patrol or transportation scenarios; (3) Oscillating movement: nodes oscillate along a single axis (x or y) with sinusoidal motion, amplitude, and frequency parameters, simulating back-and-forth patterns. Importantly, mobile nodes maintain their original communication capabilities and energy harvesting attributes, enabling evaluation of energy cooperation under dynamic topologies. The mobility is deterministic when initialized with fixed random seeds, ensuring reproducibility while introducing controlled topology variations.
```

**代码依据**：
- `src/core/SensorNode.py` lines 262-293 (update_position方法)
- `src/core/network.py` lines 297-312 (移动节点分配逻辑)

---

### 6. **节点拓扑分布模式**

**建议位置**：在等边三角形网格拓扑描述之后

**内容补充**：
```
Beyond the primary equilateral triangular grid topology, the model also supports random spatial distribution to accommodate diverse deployment scenarios and comparative studies. In random distribution mode, node positions are generated using rejection sampling with a minimum inter-node distance constraint (typically 0.5 m) to prevent physical overlap and ensure realistic deployment density. The sampling process attempts to place nodes uniformly within a defined rectangular area (e.g., 10×10 m² for small networks), with adaptive relaxation of the minimum distance constraint if initial attempts fail. Additionally, the model can generate hybrid distributions combining uniform core regions with random edge placement, or clustered distributions based on geographic constraints. Both distribution modes maintain the same node attribute assignments (solar ratio, mobility ratio) and energy evolution mechanics, allowing fair comparison of topology effects on energy cooperation performance. The random seed parameter ensures reproducibility of specific topology instances across different experimental runs.
```

**代码依据**：
- `src/core/network.py` lines 205-238 (_generate_uniform_positions)
- `src/core/network.py` lines 240-302 (_generate_random_positions)

---

### 7. **能量演化时序模型**

**建议位置**：作为能量演化的总述

**内容补充**：
```
The energy state evolution of each node follows a discrete-time update model executed at each simulation time step. At time t, each node's energy is updated as: E(t+1) = E(t) + E_harvest(t) - E_decay(t), where E_harvest(t) is the solar energy collected (non-zero only for solar-capable nodes and during daylight hours), and E_decay(t) represents natural battery self-discharge (typically 5 J per step) and sensor operation baseline consumption (0.1 J per step). The energy is bounded between 0 (depleted) and the battery capacity (capacity × voltage × 3600, converted from mAh to Joules). When energy transfer operations occur during the same time step, the received energy from WET is added: E(t+1) = E(t) + E_harvest(t) - E_decay(t) + E_received - E_transmitted, where E_transmitted includes both the transferred energy and communication overhead. This sequential update ensures energy conservation across the network while accounting for all energy sources and sinks, providing a complete energy balance for realistic simulation of long-term network operation.
```

**代码依据**：
- `src/core/SensorNode.py` lines 246-260 (update_energy方法)
- `src/core/energy_simulation.py` (主仿真循环中的能量更新顺序)

---

## 二、建议作为其他Methodology小节的内容

这些内容更适合作为**独立的算法/策略**小节，而不是纯粹的**建模**内容：

---

### 1. **3.2 Adaptive Energy Cooperation Strategy (ADCR Algorithm)** 
   **或放在 3.1 Modeling 之后作为 3.2**

**内容概述**：
- ADCR（自适应动态协作路由）算法的核心设计
- 虚拟中心计算机制（几何中心 vs 能量加权中心）
- 最优簇数K*的估计方法（基于近邻度方差）
- 簇头选择策略（能量感知+空间抑制）
- 三阶段通信能耗结算模型（簇内→簇间→虚拟跳）
- 信息聚合与路径规划
- 与能量调度的协同机制

**关键点**：
- 这不是"建模"而是"算法设计"
- 可以描述ADCR如何利用前面建立的模型来实现协作
- 强调自适应性和动态调整

---

### 2. **3.3 Intelligent Passive Energy Transfer System**
   **或作为 3.2 的子节**

**内容概述**：
- 智能被动传能与传统定时主动传能的对比
- 多维度触发决策机制：
  - 检查间隔控制
  - 冷却期机制
  - 低能量节点比例阈值
  - 能量分布方差评估
  - 预测性触发（可选）
- 参数配置策略（快速响应/均衡/节能）
- 性能优势分析

**关键点**：
- 这是"控制策略"而非"模型定义"
- 可以量化说明相比定时触发减少的传能次数和能量浪费

---

### 3. **3.4 Adaptive K-Value Selection Mechanism**
   **或作为调度算法的一部分**

**内容概述**：
- K值的定义（每个接收端可匹配的最大捐能者数量）
- 自适应调整的奖励函数设计：
  - 均衡改进（能量标准差降低）
  - 有效送达量
  - 传输损耗惩罚
- 滞回阈值机制（防止振荡）
- 前瞻性K值选择（基于短期模拟评估）
- 归一化策略确保不同指标的可比性

**关键点**：
- 这是"参数优化策略"而非"模型参数"
- 可以放在"Adaptive Energy Cooperation Strategy"部分，说明K值如何与ADCR协同

---

### 4. **3.5 Energy-Efficient Opportunistic Routing (EEOR)**
   **可以合并到现有的多跳路由描述中，或单独成节**

**内容概述**：
- EEOR算法的数学公式（期望代价计算）
- 自适应邻居发现机制
- 链路误码率模型
- 路径选择的多目标优化（距离、能量、误码率）
- 与能量调度的集成方式

**关键点**：
- 可以扩展你已有的EEOR描述
- 强调与能量传输效率模型的结合

---

### 5. **3.6 Scheduling Algorithms**
   **可以单独成节，说明不同调度器的设计**

**内容概述**：
- LyapunovScheduler：漂移+惩罚框架
- ClusterScheduler：基于簇的调度
- PredictionScheduler：基于预测的调度
- BaselineHeuristic：基线启发式
- 各调度器如何利用NodeInfoManager获取实时状态

**关键点**：
- 可以作为"方法"而不是"模型"来描述
- 强调不同调度器的适用场景

---

### 6. **3.7 Node Information Management System**
   **可以作为支撑系统介绍**

**内容概述**：
- NodeInfoManager的设计（InfoNode与SensorNode的同步机制）
- 信息新鲜度（freshness）和年龄（age）模型
- 置信度评估
- 三层信息存储架构（内存、历史队列、CSV归档）

**关键点**：
- 这是"系统架构"而非"网络模型"
- 可以说明如何确保调度器获得准确的状态信息

---

### 7. **3.8 Intelligent Continuous Transfer: How Much to Transfer**
   **或作为 3.3 的子节（“传多少”的连续优化）**

**内容概述**：
- 目标：在一次传能会话中自适应确定传输量 ΔE，以最大化“净有效到达能量 − 通信结算开销 − 风险成本”
- 优化框架（单跳情形）：
  - 目标函数：maximize NetGain(ΔE) = η(d)·ΔE − C_comm(ΔE) − C_risk(ΔE)
  - 约束：0 ≤ ΔE ≤ min(E_donor − E_safe, E_recv_max − E_recv, ΔE_step_max)
  - 其中 C_comm(ΔE) = C_fix + c_lin·ΔE（结合三阶段结算模型中的固定与线性项），C_risk 体现捐/受端越界风险（如低电保护/溢出惩罚）
- 连续传输策略：
  - 边际判据：当 d/dΔE[NetGain] ≤ 0 时停止本轮；支持分批次“连续小额”传输以降低失败重传概率
  - 安全缓冲：为捐能端保留 E_safe，为受能端设置目标缓冲带 [E_target_low, E_target_high]
  - 粒度与冷却：设置最小粒度 ΔE_min、最大步长 ΔE_step_max 及冷却期，避免振荡
- 多跳扩展：将 η_path = ∏η_i 代入；通信结算采用路径分摊（簇内→簇间→虚拟跳）

**实现要点**：
- 作为 `passive_transfer` 的“会话级控制”，对每个候选对实时评估 η(d)、通信开销、能量边界，求解（或启发式逼近）最优 ΔE
- 失败/中断重试采用指数退避并衰减 ΔE_step_max

**与现有模块的关系**：
- 利用：
  - `src/core/SensorNode.py` 的 `energy_transfer_efficiency()`（η(d)）与能耗结算相关方法
  - `src/scheduling/passive_transfer.py` 的触发/会话控制框架
  - `src/acdr/adcr_link_layer.py` 提供路由/链路信息与结算阶段划分

**关键点**：
- 明确“传多少”属于控制策略，不是物理模型；但需引用前述通信能耗与效率模型
- 强调连续小额与边际收益停机准则，减少无效通信与ACK往返

---

### 8. **3.9 Path-Crossing Aware Deferred Transfer**
   **或作为 3.4 调度算法的子节（路径交叉下的延迟传输）**

**内容概述**：
- 问题：多条传能路径在时间/空间上发生“交叉”（共享节点/链路/时隙），导致额外控制开销与冲突
- 思路：当“合并/延迟后批量执行”的通信结算开销节省 > 延迟风险（能量老化/需求错过）时，采用延迟与批量调度
- 判据：若 ΔC_comm_save − ΔRisk_delay ≥ θ（阈值）且等待时间 ≤ T_max，则进入延迟队列
- 队列与排序：
  - 建立“交叉度图”，按交叉度/紧急度排序批次
  - 同批内进行路径去重与时隙编排，减少路由切换与握手次数
- 风险控制：
  - 对受端设置最晚满足时间 T_deadline 与老化系数 α_age，超限强制下发
  - 供端能量跌破 E_safe 即取消延迟

**实现要点**：
- 在调度层构建“延迟候选池”，与即时执行池并行评估；周期性重评估转移
- 结合 ADCR 的簇级路由，优先在同簇/同干道内合并，减少跨簇切换

**与现有模块的关系**：
- 可扩展：
  - `src/acdr/adcr_link_layer.py`（路径与簇信息，可提供交叉度评估）
  - `src/scheduling/passive_transfer.py`（加入延迟队列与批次执行机制）
  - `src/core/SensorNode.py`（提供能量与时间窗约束信息）

**关键点**：
- 该策略属于“调度/控制”，核心在判据与老化/截止控制的权衡
- 通过减少握手/ACK/路由切换次数来显著节省通信能耗

---

## 三、建议的结构组织

### 推荐结构1（聚焦建模+核心算法）：

```
3. Methodology
  3.1 Experimental Model and System Design
    3.1.1 Network Topology and Node Deployment
    3.1.2 Node Heterogeneity and Attributes
    3.1.3 Energy Dynamics and Harvesting Models
    3.1.4 Communication Energy Consumption Model
    3.1.5 Wireless Energy Transfer Efficiency Model
    3.1.6 Energy Evolution Discrete-Time Model
  
  3.2 Adaptive Dynamic Cooperative Routing (ADCR)
    3.2.1 Virtual Center Computation
    3.2.2 Optimal Clustering Strategy
    3.2.3 Cluster Head Selection
    3.2.4 Multi-Hop Path Planning
    3.2.5 Three-Phase Energy Settlement
  
  3.3 Intelligent Passive Energy Transfer System
    3.3.1 Trigger Decision Mechanism
    3.3.2 Multi-Dimensional Evaluation
    3.3.3 Parameter Configuration Strategies
    3.3.4 Intelligent Continuous Transfer (How Much to Transfer)
  
  3.4 Energy Scheduling Algorithms
    3.4.1 Lyapunov-Based Scheduler
    3.4.2 Adaptive K-Value Selection
    3.4.3 Integration with EEOR Routing
    3.4.4 Path-Crossing Aware Deferred Transfer
```

### 推荐结构2（更传统的组织方式）：

```
3. Methodology
  3.1 System Model
    [包含所有建模内容，如你现在的描述+上述补充]
  
  3.2 Adaptive Energy Cooperation Algorithm
    3.2.1 ADCR Framework
    3.2.2 Intelligent Passive Transfer
    3.2.3 Intelligent Continuous Transfer (How Much to Transfer)
    3.2.4 Adaptive Parameter Tuning
  
  3.3 Supporting Mechanisms
    3.3.1 EEOR Routing Protocol
    3.3.2 Path-Crossing Aware Deferred Transfer
    3.3.3 Node Information Management
```

---

## 四、补充内容的撰写建议

### 量化细节的平衡：
- **建模章节**：应该包含足够的数学公式和参数范围，使读者能够复现
- **算法章节**：重点描述"怎么做"而不是"模型是什么"

### 与现有内容的衔接：
- 在"建模"部分提到"这些模型支持后续的ADCR算法和智能被动传能"，建立桥梁
- 在"算法"部分引用前面建立的模型，说明算法如何利用这些模型

### 扩展性描述的更新：
- 在扩展性部分可以提到："The model framework also supports dynamic parameter adaptation (such as K-value self-tuning), intelligent transfer triggering (passive mode), and cluster-based energy coordination (ADCR), which are detailed in Section 3.2."

---

## 五、代码引用建议

在撰写时，如果需要在技术报告中引用实现细节，可以参考：

1. **能量演化模型**：`src/core/SensorNode.py` 的 `update_energy()` 方法
2. **能耗计算**：`src/core/SensorNode.py` 的 `energy_consumption()` 方法
3. **传输效率**：`src/core/SensorNode.py` 的 `energy_transfer_efficiency()` 方法
4. **太阳能采集**：`src/core/SensorNode.py` 的 `solar_irradiance()` 和 `energy_harvest()` 方法
5. **拓扑生成**：`src/core/network.py` 的 `_generate_uniform_positions()` 和 `_generate_random_positions()` 方法
6. **ADCR算法**：`src/acdr/adcr_link_layer.py`
7. **智能被动传能**：`src/scheduling/passive_transfer.py`
8. **K值自适应**：`src/dynamic_k/k_adaptation.py`

这些都可以作为实现细节的佐证，增加技术报告的可信度。


