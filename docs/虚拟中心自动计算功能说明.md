# 虚拟中心自动计算功能说明

## 概述

虚拟中心（`VirtualCenter`）是WSN中的逻辑汇聚点（Sink），具有以下特性：
- 假设拥有**无限能量**
- 位置**动态更新**（基于网络节点分布）
- **不对应真实节点**，但通过锚点（Anchor）接收数据

---

## 核心自动计算功能

### 1. 位置自动更新（`update_position`）

**触发时机：**
- 每次ADCR周期开始时（默认24小时）
- 在 `ADCRLinkLayerVirtual.step(t)` 中调用

**更新策略（`update_strategy`）：**

#### 策略1：几何中心（`geometric_center`，默认）
```python
# 计算所有节点位置的算术平均
vc_x = sum(node.x for node in nodes) / len(nodes)
vc_y = sum(node.y for node in nodes) / len(nodes)
```

**特点：**
- ✅ 简单、公平
- ✅ 不受能量分布影响
- ✅ 最小化平均通信距离

#### 策略2：能量加权中心（`energy_weighted_center`）
```python
# 能量越高的节点权重越大
total_energy = sum(n.current_energy for n in nodes)
vc_x = sum(n.x * n.current_energy for n in nodes) / total_energy
vc_y = sum(n.y * n.current_energy for n in nodes) / total_energy
```

**特点：**
- ✅ 虚拟中心偏向能量充足的区域
- ✅ 减少低能量节点的通信负担
- ⚠️ 可能导致位置偏移较大

#### 策略3：固定位置（`fixed`）
```python
# 位置不变，保持初始值
vc_position = initial_position
```

**特点：**
- ✅ 稳定、可预测
- ⚠️ 无法适应网络拓扑变化

---

### 2. 锚点自动选择（`find_anchor`）

**锚点定义：**
锚点是虚拟中心在物理网络中的"代表"，负责接收并转发到虚拟中心的数据。

**选择规则：**
```python
# 1. 过滤死亡节点（能量为0）
alive_nodes = [n for n in nodes if n.current_energy > 0]

# 2. 过滤低能量节点（可选）
candidates = [n for n in alive_nodes if n.current_energy >= min_energy_threshold]

# 3. 选择最靠近虚拟中心的节点
anchor = min(candidates, key=lambda n: distance(n, vc))
```

**触发时机：**
- 每次ADCR周期开始时
- 在路径规划（`plan_paths_from_cluster_heads`）前自动调用

**示例输出：**
```
[VirtualCenter] 锚点选择: Node 15, 距离虚拟中心 2.345m, 能量 1250.5J
```

---

### 3. 路径规划（`plan_paths_from_cluster_heads`）

**功能：**
为所有簇头（Cluster Heads）规划到虚拟中心的上行路径。

**规划策略：**

#### 情况1：簇头即为锚点
```python
if cluster_head is anchor:
    path = [cluster_head]  # 只有虚拟跳
```
- 簇头直接上报到虚拟中心
- 无多跳开销

#### 情况2：直接传输优化
```python
# 如果簇头到锚点的距离 < 网络直径 × 阈值（默认0.1）
if distance(cluster_head, anchor) < network_diameter * 0.1:
    path = [cluster_head]  # 直接传输到虚拟中心
```
- **网络直径**：所有节点两两距离的最大值
- **阈值**：`direct_transmission_threshold`（默认0.1）
- 避免不必要的多跳

#### 情况3：多跳路径
```python
# 使用路由函数（如EEOR）规划路径
path = routing_function(all_nodes, cluster_head, anchor, max_hops=5)
# 例如: [ch, relay1, relay2, anchor]
```
- 使用EEOR（Energy-Efficient Opportunistic Routing）
- 考虑能量、距离等因素
- 自动回退到直接传输（如果规划失败）

**路径示例：**
```
CH 3: 多跳路径: 3 → 7 → 12 → 15(anchor) → VC
CH 5: 直接传输到虚拟中心（距离锚点 < 阈值）
CH 8: 即为锚点，只有虚拟跳
```

---

### 4. 虚拟跳能耗计算（`calculate_virtual_hop_energy`）

**虚拟跳定义：**
从真实节点（通常是锚点或簇头）到虚拟中心的逻辑通信。

**能耗模型：**
```python
# 1. 计算到虚拟中心的距离
distance = sqrt((node.x - vc.x)^2 + (node.y - vc.y)^2)

# 2. 发射能耗
E_tx = E_elec * data_size + epsilon_amp * data_size * (distance ^ tau)

# 3. 接收能耗（虚拟的，用于计算总开销）
E_rx = E_elec * data_size

# 4. 总能耗（按比例分配 + 传感器能耗）
E_total = tx_rx_ratio * (E_tx + E_rx) + sensor_energy
```

**参数说明：**
- `data_size`：数据包大小（bits）
- `tx_rx_ratio`：发送/接收能耗分配比例（默认0.5）
- `sensor_energy`：传感器能耗（默认0.1J）
- `tau`：路径损耗指数（默认2.0）

**关键特性：**
- ✅ **只扣发送端能量**（虚拟中心无限能量）
- ✅ 使用聚合数据量（非原始数据）
- ✅ 基于真实距离计算

**示例：**
```
[VirtualCenter] 虚拟跳能耗: Node 15 → VC, 距离=2.35m, 数据=1000000bits, 能耗=1.234J
[VirtualCenter] Node 15 能量扣除 1.23J, 剩余 1249.3J
```

---

### 5. 节点信息表自动更新（`update_node_info`）

**触发时机：**
- ADCR周期完成后（`_update_virtual_center_info`）
- PathCollector每次信息收集后

**更新内容：**
```python
{
    'energy': float,           # 节点当前能量
    'freshness': int,          # 信息新鲜度（采集时间）
    'arrival_time': int,       # 到达虚拟中心的时间
    'position': (x, y),        # 节点位置
    'is_solar': bool,          # 是否有太阳能
    'cluster_id': int,         # 所属簇ID
    'data_size': int,          # 数据包大小
    'age': int                 # 信息年龄（延迟）= arrival_time - freshness
}
```

**三级缓存架构：**

#### L1：最新状态表（`latest_info`）
- **数据结构**：字典 `{node_id: info}`
- **容量**：无限制
- **查询复杂度**：O(1)
- **用途**：快速查询节点最新状态

#### L2：近期历史（`recent_history`）
- **数据结构**：固定大小deque（默认1000条）
- **容量**：`history_size`（默认1000）
- **用途**：历史趋势分析、估算准确度评估

#### L3：长期归档（CSV文件）
- **文件路径**：`data/{session}/virtual_center_node_info.csv`
- **批量写入**：积累100条后批量写入（减少I/O开销）
- **用途**：后处理分析、可视化

**CSV文件格式：**
```csv
timestamp,node_id,energy,freshness,age,is_solar,confidence
100,0,980.5,100,0,True,1.0
100,1,950.2,100,0,False,1.0
```

---

## ADCR中的自动计算流程

```
每个ADCR周期（默认24小时）:
    ↓
1️⃣ 更新虚拟中心位置
    self.vc.update_position(nodes, current_time=t)
    └─> 计算几何中心/能量加权中心
    
    ↓
2️⃣ 估计最优簇数 K*
    K_star = self._estimate_K_star()
    └─> 基于能量、距离、数据量的优化模型
    
    ↓
3️⃣ 选择簇头
    cluster_heads = self._select_ch(K_star)
    └─> 基于能量、距离的贪心算法
    
    ↓
4️⃣ 成簇
    self._clustering(cluster_heads)
    └─> 非簇头节点加入最近的簇
    
    ↓
5️⃣ 路径规划（自动选择锚点）
    self._plan_paths_to_virtual()
    ├─> self.vc.find_anchor(nodes)      # 自动选择锚点
    └─> self.vc.plan_paths_from_cluster_heads()  # 规划路径
    
    ↓
6️⃣ 结算通信能耗
    self._settle_comm_energy()
    ├─> 簇内通信：成员 → 簇头
    ├─> 簇间通信：簇头 → ... → 锚点
    └─> 虚拟跳：锚点/簇头 → 虚拟中心
        └─> self.vc.settle_virtual_hop_energy()  # 自动计算并扣能量
    
    ↓
7️⃣ 更新节点信息表
    self._update_virtual_center_info(t)
    └─> self.vc.update_node_info()  # 批量更新所有节点信息
```

---

## 配置参数

### VirtualCenter初始化参数

```python
vc = VirtualCenter(
    initial_position=(0.0, 0.0),     # 初始位置
    update_strategy="geometric_center",  # 位置更新策略
    enable_logging=True,              # 启用日志
    history_size=1000,                # 近期历史缓存大小
    archive_path="data/session/virtual_center_node_info.csv"  # 归档路径
)
```

### 锚点选择参数

```python
anchor = vc.find_anchor(
    nodes=all_nodes,
    min_energy_threshold=0.0,    # 最小能量阈值（J）
    exclude_dead_nodes=True       # 排除死亡节点
)
```

### 路径规划参数

```python
paths = vc.plan_paths_from_cluster_heads(
    cluster_heads=ch_nodes,
    all_nodes=all_nodes,
    routing_function=eeor_find_path_adaptive,  # 路由函数
    max_hops=5,                               # 最大跳数
    enable_direct_transmission=True,          # 启用直接传输优化
    direct_transmission_threshold=0.1         # 直接传输阈值
)
```

### 虚拟跳能耗参数

```python
energy = vc.calculate_virtual_hop_energy(
    sender=node,
    data_size=1000000,      # 数据大小（bits）
    tx_rx_ratio=0.5,        # 发送/接收能耗比例
    sensor_energy=0.1       # 传感器能耗（J）
)
```

---

## 调试和监控

### 日志输出

启用 `enable_logging=True` 后，虚拟中心会输出详细日志：

```
[VirtualCenter] 初始化虚拟中心，位置: (0.0, 0.0), 策略: geometric_center
[VirtualCenter] 节点信息表已启用，历史缓存: 1000 条
[VirtualCenter] 位置更新为: (25.234, 18.567)
[VirtualCenter] 锚点选择: Node 15, 距离虚拟中心 2.345m, 能量 1250.5J
[VirtualCenter] CH 3: 距锚点 8.23m < 网络直径 45.67m × 0.1 = 4.57m, 使用直接传输
[VirtualCenter] CH 5 多跳路径: 5 → 7 → 12 → 15 → VC
[VirtualCenter] 虚拟跳能耗: Node 15 → VC, 距离=2.35m, 数据=1000000bits, 能耗=1.234J
[VirtualCenter] Node 15 能量扣除 1.23J, 剩余 1249.3J
[VirtualCenter] 虚拟中心更新: 30 个节点
```

### 统计信息查询

```python
# 获取虚拟中心统计
stats = vc.get_statistics()
print(f"节点总数: {stats['total_nodes']}")
print(f"平均能量: {stats['avg_energy']:.2f}J")
print(f"低能量节点数: {stats['low_energy_nodes']}")
print(f"最旧信息年龄: {stats['max_info_age']} 分钟")
```

### 可视化数据

```python
# 获取可视化数据
viz_data = vc.get_visualization_data()
# 包含：节点位置、能量、信息年龄等，可用于绘图
```

---

## 与PathCollector的集成

PathCollector可以复用虚拟中心的能量计算功能：

```python
# PathCollector在full模式下
# 1. 路径逐跳：使用 SensorNode.energy_consumption()
# 2. 虚拟跳：使用 VirtualCenter.settle_virtual_hop_energy()

E_virtual = vc.settle_virtual_hop_energy(
    sender=receiver,  # 路径终点
    data_size=base_data_size,  # 固定数据包大小
    tx_rx_ratio=0.5,
    sensor_energy=0.1
)
```

**关键特性：**
- ✅ 能量计算与ADCR完全一致
- ✅ 自动扣除发送端能量
- ✅ 虚拟中心不消耗能量

---

## 扩展与未来工作

### 可能的扩展方向

1. **多虚拟中心**
   - 支持多个虚拟中心（分布式）
   - 虚拟中心之间负载均衡

2. **移动虚拟中心**
   - 虚拟中心根据网络状态动态移动
   - 追踪能量热点区域

3. **自适应阈值**
   - 根据网络密度动态调整 `direct_transmission_threshold`
   - 优化通信开销

4. **能量预测**
   - 基于历史数据预测节点能量变化
   - 提前调整虚拟中心位置和锚点

---

## 相关文档

- [虚拟中心节点信息表使用说明](./虚拟中心节点信息表使用说明.md)
- [路径信息收集器使用说明](./路径信息收集器使用说明.md)
- [ADCR协议说明](../src/acdr/README.md)

---

**版本**: v1.0  
**最后更新**: 2024-10-28  
**作者**: WSN_ES Team

