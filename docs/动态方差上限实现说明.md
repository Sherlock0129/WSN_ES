# 动态方差上限实现说明

## 概述

动态方差上限（Dynamic Variance Threshold）是一种自适应机制，用于根据系统状态自动调整能量方差阈值，避免频繁触发能量传输，同时保持系统对能量不均衡的敏感度。

## 实现机制

### 核心思想

1. **上调机制**：当系统频繁触发传能时（连续满足触发条件），自动提高方差阈值，减少不必要的传能
2. **下调机制**：当系统稳定时（连续不触发），自动降低方差阈值，恢复对能量不均衡的敏感度
3. **边界保护**：设置阈值上限和下限，防止阈值过高导致传能失效，或过低导致过度敏感

### 工作流程

```
检查能量状态
    ↓
是否满足触发条件？
    ↓
是 → 连续触发计数 +1
    ↓
    连续触发 ≥ adaptive_threshold_steps?
    ↓
    是 → 阈值上调（+threshold_increment，不超过threshold_max）
    ↓
否 → 连续稳定计数 +1
    ↓
    连续稳定 ≥ threshold_stability_steps?
    ↓
    是 → 阈值下调（-threshold_decrement，不低于threshold_min）
```

## 配置参数

在 `SimulationConfig` 中可以配置以下参数：

### 基本参数

| 参数名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `enable_adaptive_variance_threshold` | bool | `True` | 是否启用动态方差上限自适应 |
| `energy_variance_threshold` | float | `0.05` | 初始能量方差阈值（变异系数） |

### 上调参数

| 参数名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `adaptive_threshold_steps` | int | `10` | 连续触发步数阈值（达到此次数后上调阈值） |
| `threshold_increment` | float | `0.05` | 阈值上调增量（每次调整增加的幅度） |
| `threshold_max` | float | `0.5` | 方差阈值上限（防止阈值过高导致传能失效） |

### 下调参数

| 参数名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `threshold_stability_steps` | int | `20` | 稳定步数阈值（连续不触发此次数后下调阈值） |
| `threshold_decrement` | float | `0.02` | 阈值下调增量（当系统稳定时降低阈值） |
| `threshold_min` | float | `0.01` | 方差阈值下限（保持最小灵敏度） |

## 使用示例

### 1. 默认配置（推荐）

```python
from src.config.simulation_config import ConfigManager

config_manager = ConfigManager()
# 使用默认参数，启用动态方差上限自适应
simulation = config_manager.create_energy_simulation(network, scheduler)
```

### 2. 自定义配置

```python
from src.config.simulation_config import ConfigManager

config_manager = ConfigManager()

# 配置动态方差上限参数
config_manager.simulation_config.enable_adaptive_variance_threshold = True
config_manager.simulation_config.energy_variance_threshold = 0.1  # 初始阈值
config_manager.simulation_config.adaptive_threshold_steps = 15     # 更保守（需要15次连续触发才上调）
config_manager.simulation_config.threshold_increment = 0.03         # 更小的上调幅度
config_manager.simulation_config.threshold_stability_steps = 30     # 更长的稳定期才下调
config_manager.simulation_config.threshold_decrement = 0.01         # 更小的下调幅度
config_manager.simulation_config.threshold_max = 0.4                # 更低的阈值上限
config_manager.simulation_config.threshold_min = 0.02               # 更高的阈值下限

simulation = config_manager.create_energy_simulation(network, scheduler)
```

### 3. 禁用动态调整

```python
config_manager.simulation_config.enable_adaptive_variance_threshold = False
# 此时使用固定的 energy_variance_threshold，不会自动调整
```

## 参数调优建议

### 快速响应型（高灵敏度）

适用于需要快速响应能量不均衡的场景：

```python
adaptive_threshold_steps = 5      # 较少次数就上调
threshold_increment = 0.03         # 较小上调幅度
threshold_stability_steps = 10     # 较快恢复灵敏度
threshold_decrement = 0.03         # 较大下调幅度
threshold_max = 0.3                # 较低上限
threshold_min = 0.01               # 较低下限
```

### 均衡型（推荐）

平衡响应速度和稳定性：

```python
adaptive_threshold_steps = 10     # 默认值
threshold_increment = 0.05         # 默认值
threshold_stability_steps = 20     # 默认值
threshold_decrement = 0.02         # 默认值
threshold_max = 0.5                # 默认值
threshold_min = 0.01               # 默认值
```

### 节能型（低频率）

适用于能量传输成本较高的场景：

```python
adaptive_threshold_steps = 20     # 更多次数才上调
threshold_increment = 0.08         # 较大上调幅度
threshold_stability_steps = 40     # 更长稳定期
threshold_decrement = 0.01         # 较小下调幅度
threshold_max = 0.6                # 较高上限
threshold_min = 0.02               # 较高下限
```

## 统计信息

可以通过 `PassiveTransferManager.get_statistics()` 获取动态方差上限的统计信息：

```python
stats = simulation.passive_manager.get_statistics()

print(f"当前阈值: {stats['current_variance_threshold']:.3f}")
print(f"原始阈值: {stats['original_variance_threshold']:.3f}")
print(f"阈值调整次数: {stats['threshold_adjustment_count']}")
print(f"连续触发计数: {stats['consecutive_trigger_count']}")
print(f"连续稳定计数: {stats['consecutive_stable_count']}")
```

## 工作原理详解

### 1. 触发条件检查

系统在每个检查间隔（`check_interval`）计算能量变异系数（CV）：
```python
energy_cv = std(energies) / mean(energies)
```

如果 `energy_cv > energy_variance_threshold`，则满足触发条件。

### 2. 阈值上调

当连续 `adaptive_threshold_steps` 次检查都满足触发条件时：
```python
new_threshold = min(threshold_max, current_threshold + threshold_increment)
```

这表示系统频繁触发传能，可能是阈值过低或系统确实需要频繁传能。通过提高阈值，减少不必要的传能。

### 3. 阈值下调

当连续 `threshold_stability_steps` 次检查都不满足触发条件时：
```python
new_threshold = max(threshold_min, current_threshold - threshold_decrement)
```

这表示系统稳定，可以降低阈值以恢复对能量不均衡的敏感度。

### 4. 边界保护

- **上限保护**：防止阈值过高导致系统对能量不均衡失去响应
- **下限保护**：防止阈值过低导致系统过度敏感，频繁触发传能

## 注意事项

1. **初始阈值设置**：`energy_variance_threshold` 应该根据网络特性合理设置，建议范围 0.05-0.3
2. **调整幅度**：`threshold_increment` 和 `threshold_decrement` 应该平衡调整速度和稳定性
3. **步数阈值**：`adaptive_threshold_steps` 和 `threshold_stability_steps` 应该根据检查间隔合理设置
4. **边界值**：`threshold_max` 和 `threshold_min` 应该根据实际需求设置，避免极端情况

## 实现位置

- **配置定义**：`src/config/simulation_config.py` - `SimulationConfig` 类
- **核心实现**：`src/scheduling/passive_transfer.py` - `PassiveTransferManager` 类
- **参数传递**：`src/core/energy_simulation.py` - `EnergySimulation` 类

## 版本历史

- **v1.0**（当前）：实现基本的动态方差上限机制，支持可配置的上调和下调参数

