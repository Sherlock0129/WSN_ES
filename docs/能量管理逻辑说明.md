# 调度与路由算法的能量管理逻辑

## 📊 完整的能量管理流程

### 1️⃣ **能量存储位置**

#### `SensorNode.current_energy`
```python
# src/core/SensorNode.py
class SensorNode:
    def __init__(self, ...):
        self.current_energy = initial_energy  # 节点当前能量（J）
        self.energy_history = []              # 能量历史记录
```

**这是所有算法读取和修改能量的唯一来源**

---

### 2️⃣ **主模拟循环（能量更新顺序）**

```python
# src/core/energy_simulation.py - simulate()

for t in range(time_steps):
    # ┌─────────────────────────────────────────────────┐
    # │ Step 1: 自然能量更新（采集 + 衰减）              │
    # └─────────────────────────────────────────────────┘
    self.network.update_network_energy(t)
    # → 调用每个节点的 node.update_energy(t)
    # → 修改 node.current_energy
    
    # ┌─────────────────────────────────────────────────┐
    # │ Step 1.5: ADCR 链路层处理（如果启用）           │
    # └─────────────────────────────────────────────────┘
    if hasattr(self.network, 'adcr_link'):
        self.network.adcr_link.step(t)
        # → 簇内通信和虚拟跳会消耗能量
        # → 直接修改 node.current_energy
    
    # ┌─────────────────────────────────────────────────┐
    # │ Step 2: 智能被动传能触发判断                     │
    # └─────────────────────────────────────────────────┘
    should_trigger, reason = self.passive_manager.should_trigger_transfer(t, network)
    
    if should_trigger:
        # ┌─────────────────────────────────────────────┐
        # │ Step 3: 调度算法规划传能                     │
        # └─────────────────────────────────────────────┘
        plans = self.scheduler.plan(self.network, t)
        # → 读取所有 node.current_energy
        # → 返回传能计划列表
        
        # ┌─────────────────────────────────────────────┐
        # │ Step 4: 执行传能（扣除能量）                 │
        # └─────────────────────────────────────────────┘
        self.network.execute_energy_transfer(plans)
        # → 修改 donor.current_energy（扣除发送能量 + 通信损耗）
        # → 修改 receiver.current_energy（增加接收能量）
        # → 修改中继节点能量（多跳路径）
        
        # ┌─────────────────────────────────────────────┐
        # │ Step 5: K值自适应调整                        │
        # └─────────────────────────────────────────────┘
        if self.enable_k_adaptation:
            self.k_adaptation.adapt(...)
    
    # ┌─────────────────────────────────────────────────┐
    # │ Step 6: 记录统计数据                             │
    # └─────────────────────────────────────────────────┘
    self.stats.record_energy_stats(...)
```

---

## 🔄 **调度算法如何使用能量**

### **所有调度算法的共同模式**

```python
def plan(self, network, t):
    nodes = network.nodes  # 获取所有节点
    
    # 1️⃣ 读取所有节点的当前能量
    avgE = np.mean([n.current_energy for n in nodes])
    
    # 2️⃣ 根据能量筛选接收方（低能量节点）
    receivers = [n for n in nodes if n.current_energy < avgE]
    
    # 3️⃣ 根据能量筛选发送方（高能量节点）
    donors = [n for n in nodes if n.current_energy > avgE]
    
    # 4️⃣ 规划传能配对
    plans = []
    for receiver in receivers:
        for donor in donors:
            # 读取能量进行决策
            if donor.current_energy > some_threshold:
                plans.append({
                    "receiver": receiver,
                    "donor": donor,
                    "path": path,
                    "distance": distance
                })
    
    return plans  # 返回计划，不修改能量
```

### **关键点：调度算法只读取能量，不修改能量**

---

## 📍 **5种调度算法的能量使用细节**

### 1. **BaselineHeuristic（基线启发式）**

```python
# src/scheduling/schedulers.py - Line 38-40
avgE = float(np.mean([n.current_energy for n in nodes]))
lows = sorted([n for n in nodes if n.current_energy < avgE],
              key=lambda x: (avgE - x.current_energy), reverse=True)

# Line 43
cand = [n for n in nodes if (n is not r) and 
        (n.current_energy > avgE) and (n not in used)]

# Line 46
cand.sort(key=lambda d: (-d.current_energy, r.distance_to(d)))
```

**使用的能量属性：**
- ✅ `node.current_energy` - 筛选低/高能量节点
- ✅ 按能量排序 - 优先高能量节点作为donor

---

### 2. **LyapunovScheduler（Lyapunov优化）**

```python
# Line 78-84
avgE = float(np.mean([n.current_energy for n in nodes]))
E_bar = avgE if avgE > 0 else 1.0
Q = dict((n, max(0.0, avgE - n.current_energy)) for n in nodes)
receivers = [n for n in nodes if n.current_energy < avgE]
donors = [n for n in nodes if n.current_energy > avgE]

# Line 108
Q_normalized = Q[r] / E_bar
score = eta * (Q_normalized + self.V) - self.V
```

**使用的能量属性：**
- ✅ `node.current_energy` - 计算能量缺口 Q
- ✅ 归一化能量 - 计算决策分数

---

### 3. **ClusterScheduler（簇调度）**

```python
# Line 174
avgE = float(np.mean([m.current_energy for m in members]))

# Line 175-177
lows = sorted([m for m in members if m.current_energy < avgE],
              key=lambda x: avgE - x.current_energy, reverse=True)
highs = [m for m in members if m.current_energy > avgE]

# Line 192
highs_sorted = sorted(highs, key=lambda x: (-x.current_energy, ch.distance_to(x)))
```

**使用的能量属性：**
- ✅ `node.current_energy` - 簇内能量均衡
- ✅ 簇头优先充能策略

---

### 4. **PredictionScheduler（预测调度）**

```python
# Line 225-226
avgE = float(np.mean([n.current_energy for n in nodes]))
pred_surplus = dict((n, (n.current_energy + self._predict_harvest(n, t))) for n in nodes)

# Line 228-229
receivers = sorted([n for n in nodes if n.current_energy < avgE],
                   key=lambda n: (avgE - n.current_energy), reverse=True)

# Line 234
cand = [n for n in nodes if (n is not r) and (pred_surplus[n] > avgE) and (n not in used)]

# Line 237
cand.sort(key=lambda d: (-pred_surplus[d], r.distance_to(d)))
```

**使用的能量属性：**
- ✅ `node.current_energy` - 当前能量状态
- ✅ **预测未来能量** - `current_energy + 预测采集量`

---

### 5. **PowerControlScheduler（功率控制）**

```python
# Line 271
avgE = float(np.mean([n.current_energy for n in nodes]))

# Line 272-273
receivers = sorted([n for n in nodes if n.current_energy < avgE],
                   key=lambda n: (avgE - n.current_energy), reverse=True)

# Line 278
cand = [n for n in nodes if (n is not r) and (n.current_energy > avgE) and (n not in used)]

# Line 279
cand.sort(key=lambda d: (-d.current_energy, r.distance_to(d)))
```

**使用的能量属性：**
- ✅ `node.current_energy` - 筛选节点
- ✅ 按能量排序

---

## 🛣️ **路由算法如何使用能量**

### **EEOR（能量高效机会路由）**

```python
# src/routing/EEOR.py

def eeor_find_path_adaptive(nodes, src, dst, max_hops=5):
    # 1. 建立邻居关系（基于距离，不考虑能量）
    nmap, ndict = _build_neighbors_adaptive(nodes)
    
    # 2. 迭代计算最优转发集（基于链路质量，不考虑能量）
    # ...
    
    # 3. 返回路径
    return path
```

**关键发现：路由算法不直接使用能量！**

### **为什么路由不考虑能量？**

1. **职责分离**：
   - 调度算法：**选择哪些节点传能**（基于能量）
   - 路由算法：**如何到达目标**（基于链路质量）

2. **能量已在调度中考虑**：
   - 调度阶段已经筛选出高能量donor和低能量receiver
   - 路由只需找到高效路径

3. **隐式能量感知**：
   - 死亡节点（能量=0）会被自动排除
   - 路径规划失败时会跳过该传能计划

---

## ⚡ **能量消耗的时机和方式**

### **1. 自然衰减（每分钟）**

```python
# src/core/SensorNode.py - update_energy()
E_gen = self.energy_harvest(t)       # 太阳能采集
E_decay = self.energy_decay()        # 自然衰减（5 J/分钟）

self.current_energy = self.current_energy + E_gen - E_decay
```

**修改：** `node.current_energy`

---

### **2. WET传能（按计划触发）**

```python
# src/core/network.py - execute_energy_transfer()

for plan in plans:
    donor = plan["donor"]
    receiver = plan["receiver"]
    path = plan["path"]
    
    if len(path) == 2:  # 单跳
        # 发送方扣除：发送能量 + WET模块开销 + 通信损耗
        energy_sent = plan.get("energy_sent", donor.E_char)
        comm_cost = donor.energy_consumption(receiver, transfer_WET=True)
        donor.current_energy -= comm_cost
        
        # 接收方获得：发送能量 × 传输效率
        eta = donor.energy_transfer_efficiency(receiver)
        receiver.current_energy += energy_sent * eta
        
    else:  # 多跳
        for i in range(len(path) - 1):
            sender = path[i]
            receiver_i = path[i + 1]
            
            # 每一跳都扣除通信能耗
            transfer_WET = (i == 0)
            sender.current_energy -= sender.energy_consumption(receiver_i, transfer_WET)
            
            # 逐跳传递能量（有损耗）
            eta = sender.energy_transfer_efficiency(receiver_i)
            receiver_i.current_energy += energy_left * eta
            energy_left = energy_left * eta
```

**修改：**
- `donor.current_energy` ↓
- `receiver.current_energy` ↑
- `中继节点.current_energy` ↓（多跳）

---

### **3. ADCR通信（按周期触发）**

```python
# src/acdr/adcr_link_layer.py - _settle_comm_energy()

# 阶段1：簇内通信（成员 → 簇头）
for member in cluster_members:
    Eu_member, Ev_ch = self._energy_consume_one_hop(member, ch_node)
    member.current_energy -= Eu_member  # 成员扣能
    ch_node.current_energy -= Ev_ch     # 簇头扣能

# 阶段2：簇间通信（簇头 → 锚点）
for i in range(len(path) - 1):
    sender.current_energy -= Eu
    receiver.current_energy -= Ev

# 阶段3：虚拟跳（锚点 → 虚拟中心）
E_virtual = vc.settle_virtual_hop_energy(last_real, data_size)
last_real.current_energy -= E_virtual  # 只扣锚点能量
```

**修改：**
- `簇成员.current_energy` ↓
- `簇头.current_energy` ↓
- `锚点.current_energy` ↓

---

## 📋 **能量使用总结表**

| 阶段 | 操作 | 读取能量 | 修改能量 | 频率 |
|------|------|----------|----------|------|
| **1. 自然更新** | `update_network_energy()` | ❌ | ✅ 所有节点 | 每分钟 |
| **2. ADCR** | `adcr_link.step()` | ✅ 选簇头 | ✅ 通信节点 | 每24小时 |
| **3. 调度规划** | `scheduler.plan()` | ✅ 所有节点 | ❌ | 按触发 |
| **4. 路由规划** | `eeor_find_path()` | ❌ | ❌ | 按需 |
| **5. 传能执行** | `execute_energy_transfer()` | ❌ | ✅ donor/receiver/中继 | 按触发 |
| **6. 统计记录** | `record_stats()` | ✅ 所有节点 | ❌ | 按触发 |

---

## 🔑 **关键设计原则**

### **1. 单一数据源（Single Source of Truth）**
```python
# 所有算法都读写同一个属性
node.current_energy  # ← 唯一的能量来源
```

### **2. 职责分离**
- **调度算法**：决定**谁传给谁**（基于能量状态）
- **路由算法**：决定**如何传递**（基于链路质量）
- **网络层**：执行**实际传能**（修改能量）

### **3. 读写分离**
- **读取**：调度、统计、ADCR选举
- **写入**：自然更新、传能执行、ADCR通信

### **4. 时序一致性**
```
每个时间步的顺序：
  自然更新 → ADCR通信 → 调度规划 → 传能执行 → 统计记录
  ↓          ↓          ↓          ↓          ↓
  修改能量    修改能量    读取能量    修改能量    读取能量
```

---

## 🎯 **能量一致性保证**

### **问题：多处修改能量会不会冲突？**

**答：不会，因为：**

1. **严格的时序控制**：
   - 单线程执行，按固定顺序
   - 每个阶段完成后才进入下一阶段

2. **明确的修改时机**：
   - 自然更新：每分钟开始
   - ADCR通信：24小时周期
   - WET传能：被动触发（有冷却期）

3. **原子操作**：
   ```python
   # 每次修改都是原子的
   node.current_energy -= energy_cost
   node.current_energy += energy_received
   ```

---

## 📊 **能量流向图**

```
┌─────────────────────────────────────────────────────┐
│                  SensorNode.current_energy          │
│                   （所有能量的中心）                  │
└─────────────────────────────────────────────────────┘
              ↑                           ↓
              │                           │
    ┌─────────┴─────────┐       ┌────────┴────────┐
    │   能量增加         │       │   能量减少       │
    └───────────────────┘       └─────────────────┘
              ↑                           ↓
    ┌─────────┴─────────┐       ┌────────┴────────┐
    │ • 太阳能采集       │       │ • 自然衰减       │
    │ • WET接收能量      │       │ • WET发送能量    │
    │ • 多跳中继接收     │       │ • 通信损耗       │
    └───────────────────┘       │ • ADCR通信       │
                                │ • 多跳中继转发   │
                                └─────────────────┘
```

---

## 🚀 **优化建议**

### **当前实现的优点：**
- ✅ 单一数据源，易于维护
- ✅ 职责清晰，易于理解
- ✅ 时序明确，不会冲突

### **可能的改进方向：**

1. **能量历史追踪**：
   ```python
   # 记录每次能量变化的原因
   node.energy_log.append({
       "time": t,
       "type": "WET_receive",
       "delta": +300,
       "from": donor_id
   })
   ```

2. **能量预算机制**：
   ```python
   # 调度时预留能量，避免过度规划
   node.available_energy = node.current_energy - node.reserved_energy
   ```

3. **能量审计**：
   ```python
   # 每个时间步验证能量守恒
   total_energy_before = sum(n.current_energy for n in nodes)
   # ... 执行操作 ...
   total_energy_after = sum(n.current_energy for n in nodes)
   assert abs((total_after + losses) - total_before) < epsilon
   ```

---

## ✅ **总结**

### **能量使用的核心流程：**

1. **存储**：`SensorNode.current_energy` 是唯一来源
2. **读取**：调度算法读取所有节点能量，规划传能
3. **不读取**：路由算法不考虑能量，只优化路径
4. **修改**：
   - 自然更新（每分钟）
   - ADCR通信（周期性）
   - WET传能（触发式）
5. **顺序**：严格的时序保证一致性

### **关键理解：**
- 📖 **调度算法**：基于能量决策，但不修改能量
- 🛣️ **路由算法**：不考虑能量，只找最优路径
- ⚡ **网络层**：负责实际的能量修改
- 🔄 **能量守恒**：通过严格的时序控制保证

