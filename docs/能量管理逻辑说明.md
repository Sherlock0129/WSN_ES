# è°ƒåº¦ä¸è·¯ç”±ç®—æ³•çš„èƒ½é‡ç®¡ç†é€»è¾‘

## ğŸ“Š å®Œæ•´çš„èƒ½é‡ç®¡ç†æµç¨‹

### 1ï¸âƒ£ **èƒ½é‡å­˜å‚¨ä½ç½®**

#### `SensorNode.current_energy`
```python
# src/core/SensorNode.py
class SensorNode:
    def __init__(self, ...):
        self.current_energy = initial_energy  # èŠ‚ç‚¹å½“å‰èƒ½é‡ï¼ˆJï¼‰
        self.energy_history = []              # èƒ½é‡å†å²è®°å½•
```

**è¿™æ˜¯æ‰€æœ‰ç®—æ³•è¯»å–å’Œä¿®æ”¹èƒ½é‡çš„å”¯ä¸€æ¥æº**

---

### 2ï¸âƒ£ **ä¸»æ¨¡æ‹Ÿå¾ªç¯ï¼ˆèƒ½é‡æ›´æ–°é¡ºåºï¼‰**

```python
# src/core/energy_simulation.py - simulate()

for t in range(time_steps):
    # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    # â”‚ Step 1: è‡ªç„¶èƒ½é‡æ›´æ–°ï¼ˆé‡‡é›† + è¡°å‡ï¼‰              â”‚
    # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    self.network.update_network_energy(t)
    # â†’ è°ƒç”¨æ¯ä¸ªèŠ‚ç‚¹çš„ node.update_energy(t)
    # â†’ ä¿®æ”¹ node.current_energy
    
    # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    # â”‚ Step 1.5: ADCR é“¾è·¯å±‚å¤„ç†ï¼ˆå¦‚æœå¯ç”¨ï¼‰           â”‚
    # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    if hasattr(self.network, 'adcr_link'):
        self.network.adcr_link.step(t)
        # â†’ ç°‡å†…é€šä¿¡å’Œè™šæ‹Ÿè·³ä¼šæ¶ˆè€—èƒ½é‡
        # â†’ ç›´æ¥ä¿®æ”¹ node.current_energy
    
    # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    # â”‚ Step 2: æ™ºèƒ½è¢«åŠ¨ä¼ èƒ½è§¦å‘åˆ¤æ–­                     â”‚
    # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    should_trigger, reason = self.passive_manager.should_trigger_transfer(t, network)
    
    if should_trigger:
        # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        # â”‚ Step 3: è°ƒåº¦ç®—æ³•è§„åˆ’ä¼ èƒ½                     â”‚
        # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        plans = self.scheduler.plan(self.network, t)
        # â†’ è¯»å–æ‰€æœ‰ node.current_energy
        # â†’ è¿”å›ä¼ èƒ½è®¡åˆ’åˆ—è¡¨
        
        # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        # â”‚ Step 4: æ‰§è¡Œä¼ èƒ½ï¼ˆæ‰£é™¤èƒ½é‡ï¼‰                 â”‚
        # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        self.network.execute_energy_transfer(plans)
        # â†’ ä¿®æ”¹ donor.current_energyï¼ˆæ‰£é™¤å‘é€èƒ½é‡ + é€šä¿¡æŸè€—ï¼‰
        # â†’ ä¿®æ”¹ receiver.current_energyï¼ˆå¢åŠ æ¥æ”¶èƒ½é‡ï¼‰
        # â†’ ä¿®æ”¹ä¸­ç»§èŠ‚ç‚¹èƒ½é‡ï¼ˆå¤šè·³è·¯å¾„ï¼‰
        
        # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        # â”‚ Step 5: Kå€¼è‡ªé€‚åº”è°ƒæ•´                        â”‚
        # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        if self.enable_k_adaptation:
            self.k_adaptation.adapt(...)
    
    # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    # â”‚ Step 6: è®°å½•ç»Ÿè®¡æ•°æ®                             â”‚
    # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    self.stats.record_energy_stats(...)
```

---

## ğŸ”„ **è°ƒåº¦ç®—æ³•å¦‚ä½•ä½¿ç”¨èƒ½é‡**

### **æ‰€æœ‰è°ƒåº¦ç®—æ³•çš„å…±åŒæ¨¡å¼**

```python
def plan(self, network, t):
    nodes = network.nodes  # è·å–æ‰€æœ‰èŠ‚ç‚¹
    
    # 1ï¸âƒ£ è¯»å–æ‰€æœ‰èŠ‚ç‚¹çš„å½“å‰èƒ½é‡
    avgE = np.mean([n.current_energy for n in nodes])
    
    # 2ï¸âƒ£ æ ¹æ®èƒ½é‡ç­›é€‰æ¥æ”¶æ–¹ï¼ˆä½èƒ½é‡èŠ‚ç‚¹ï¼‰
    receivers = [n for n in nodes if n.current_energy < avgE]
    
    # 3ï¸âƒ£ æ ¹æ®èƒ½é‡ç­›é€‰å‘é€æ–¹ï¼ˆé«˜èƒ½é‡èŠ‚ç‚¹ï¼‰
    donors = [n for n in nodes if n.current_energy > avgE]
    
    # 4ï¸âƒ£ è§„åˆ’ä¼ èƒ½é…å¯¹
    plans = []
    for receiver in receivers:
        for donor in donors:
            # è¯»å–èƒ½é‡è¿›è¡Œå†³ç­–
            if donor.current_energy > some_threshold:
                plans.append({
                    "receiver": receiver,
                    "donor": donor,
                    "path": path,
                    "distance": distance
                })
    
    return plans  # è¿”å›è®¡åˆ’ï¼Œä¸ä¿®æ”¹èƒ½é‡
```

### **å…³é”®ç‚¹ï¼šè°ƒåº¦ç®—æ³•åªè¯»å–èƒ½é‡ï¼Œä¸ä¿®æ”¹èƒ½é‡**

---

## ğŸ“ **5ç§è°ƒåº¦ç®—æ³•çš„èƒ½é‡ä½¿ç”¨ç»†èŠ‚**

### 1. **BaselineHeuristicï¼ˆåŸºçº¿å¯å‘å¼ï¼‰**

```python
# src/scheduling/schedulers.py - Line 38-40
avgE = float(np.mean([n.current_energy for n in nodes]))
lows = sorted([n for n in nodes if n.current_energy < avgE],
              key=lambda x: (avgE - x.current_energy), reverse=True)

# Line 43
cand = [n for n in nodes if (n is not r) and 
        (n.current_energy > avgE) and (n not in used)]

# Line 46
cand.sort(key=lambda d: (-d.current_energy, r.distance_to(d)))
```

**ä½¿ç”¨çš„èƒ½é‡å±æ€§ï¼š**
- âœ… `node.current_energy` - ç­›é€‰ä½/é«˜èƒ½é‡èŠ‚ç‚¹
- âœ… æŒ‰èƒ½é‡æ’åº - ä¼˜å…ˆé«˜èƒ½é‡èŠ‚ç‚¹ä½œä¸ºdonor

---

### 2. **LyapunovSchedulerï¼ˆLyapunovä¼˜åŒ–ï¼‰**

```python
# Line 78-84
avgE = float(np.mean([n.current_energy for n in nodes]))
E_bar = avgE if avgE > 0 else 1.0
Q = dict((n, max(0.0, avgE - n.current_energy)) for n in nodes)
receivers = [n for n in nodes if n.current_energy < avgE]
donors = [n for n in nodes if n.current_energy > avgE]

# Line 108
Q_normalized = Q[r] / E_bar
score = eta * (Q_normalized + self.V) - self.V
```

**ä½¿ç”¨çš„èƒ½é‡å±æ€§ï¼š**
- âœ… `node.current_energy` - è®¡ç®—èƒ½é‡ç¼ºå£ Q
- âœ… å½’ä¸€åŒ–èƒ½é‡ - è®¡ç®—å†³ç­–åˆ†æ•°

---

### 3. **ClusterSchedulerï¼ˆç°‡è°ƒåº¦ï¼‰**

```python
# Line 174
avgE = float(np.mean([m.current_energy for m in members]))

# Line 175-177
lows = sorted([m for m in members if m.current_energy < avgE],
              key=lambda x: avgE - x.current_energy, reverse=True)
highs = [m for m in members if m.current_energy > avgE]

# Line 192
highs_sorted = sorted(highs, key=lambda x: (-x.current_energy, ch.distance_to(x)))
```

**ä½¿ç”¨çš„èƒ½é‡å±æ€§ï¼š**
- âœ… `node.current_energy` - ç°‡å†…èƒ½é‡å‡è¡¡
- âœ… ç°‡å¤´ä¼˜å…ˆå……èƒ½ç­–ç•¥

---

### 4. **PredictionSchedulerï¼ˆé¢„æµ‹è°ƒåº¦ï¼‰**

```python
# Line 225-226
avgE = float(np.mean([n.current_energy for n in nodes]))
pred_surplus = dict((n, (n.current_energy + self._predict_harvest(n, t))) for n in nodes)

# Line 228-229
receivers = sorted([n for n in nodes if n.current_energy < avgE],
                   key=lambda n: (avgE - n.current_energy), reverse=True)

# Line 234
cand = [n for n in nodes if (n is not r) and (pred_surplus[n] > avgE) and (n not in used)]

# Line 237
cand.sort(key=lambda d: (-pred_surplus[d], r.distance_to(d)))
```

**ä½¿ç”¨çš„èƒ½é‡å±æ€§ï¼š**
- âœ… `node.current_energy` - å½“å‰èƒ½é‡çŠ¶æ€
- âœ… **é¢„æµ‹æœªæ¥èƒ½é‡** - `current_energy + é¢„æµ‹é‡‡é›†é‡`

---

### 5. **PowerControlSchedulerï¼ˆåŠŸç‡æ§åˆ¶ï¼‰**

```python
# Line 271
avgE = float(np.mean([n.current_energy for n in nodes]))

# Line 272-273
receivers = sorted([n for n in nodes if n.current_energy < avgE],
                   key=lambda n: (avgE - n.current_energy), reverse=True)

# Line 278
cand = [n for n in nodes if (n is not r) and (n.current_energy > avgE) and (n not in used)]

# Line 279
cand.sort(key=lambda d: (-d.current_energy, r.distance_to(d)))
```

**ä½¿ç”¨çš„èƒ½é‡å±æ€§ï¼š**
- âœ… `node.current_energy` - ç­›é€‰èŠ‚ç‚¹
- âœ… æŒ‰èƒ½é‡æ’åº

---

## ğŸ›£ï¸ **è·¯ç”±ç®—æ³•å¦‚ä½•ä½¿ç”¨èƒ½é‡**

### **EEORï¼ˆèƒ½é‡é«˜æ•ˆæœºä¼šè·¯ç”±ï¼‰**

```python
# src/routing/EEOR.py

def eeor_find_path_adaptive(nodes, src, dst, max_hops=5):
    # 1. å»ºç«‹é‚»å±…å…³ç³»ï¼ˆåŸºäºè·ç¦»ï¼Œä¸è€ƒè™‘èƒ½é‡ï¼‰
    nmap, ndict = _build_neighbors_adaptive(nodes)
    
    # 2. è¿­ä»£è®¡ç®—æœ€ä¼˜è½¬å‘é›†ï¼ˆåŸºäºé“¾è·¯è´¨é‡ï¼Œä¸è€ƒè™‘èƒ½é‡ï¼‰
    # ...
    
    # 3. è¿”å›è·¯å¾„
    return path
```

**å…³é”®å‘ç°ï¼šè·¯ç”±ç®—æ³•ä¸ç›´æ¥ä½¿ç”¨èƒ½é‡ï¼**

### **ä¸ºä»€ä¹ˆè·¯ç”±ä¸è€ƒè™‘èƒ½é‡ï¼Ÿ**

1. **èŒè´£åˆ†ç¦»**ï¼š
   - è°ƒåº¦ç®—æ³•ï¼š**é€‰æ‹©å“ªäº›èŠ‚ç‚¹ä¼ èƒ½**ï¼ˆåŸºäºèƒ½é‡ï¼‰
   - è·¯ç”±ç®—æ³•ï¼š**å¦‚ä½•åˆ°è¾¾ç›®æ ‡**ï¼ˆåŸºäºé“¾è·¯è´¨é‡ï¼‰

2. **èƒ½é‡å·²åœ¨è°ƒåº¦ä¸­è€ƒè™‘**ï¼š
   - è°ƒåº¦é˜¶æ®µå·²ç»ç­›é€‰å‡ºé«˜èƒ½é‡donorå’Œä½èƒ½é‡receiver
   - è·¯ç”±åªéœ€æ‰¾åˆ°é«˜æ•ˆè·¯å¾„

3. **éšå¼èƒ½é‡æ„ŸçŸ¥**ï¼š
   - æ­»äº¡èŠ‚ç‚¹ï¼ˆèƒ½é‡=0ï¼‰ä¼šè¢«è‡ªåŠ¨æ’é™¤
   - è·¯å¾„è§„åˆ’å¤±è´¥æ—¶ä¼šè·³è¿‡è¯¥ä¼ èƒ½è®¡åˆ’

---

## âš¡ **èƒ½é‡æ¶ˆè€—çš„æ—¶æœºå’Œæ–¹å¼**

### **1. è‡ªç„¶è¡°å‡ï¼ˆæ¯åˆ†é’Ÿï¼‰**

```python
# src/core/SensorNode.py - update_energy()
E_gen = self.energy_harvest(t)       # å¤ªé˜³èƒ½é‡‡é›†
E_decay = self.energy_decay()        # è‡ªç„¶è¡°å‡ï¼ˆ5 J/åˆ†é’Ÿï¼‰

self.current_energy = self.current_energy + E_gen - E_decay
```

**ä¿®æ”¹ï¼š** `node.current_energy`

---

### **2. WETä¼ èƒ½ï¼ˆæŒ‰è®¡åˆ’è§¦å‘ï¼‰**

```python
# src/core/network.py - execute_energy_transfer()

for plan in plans:
    donor = plan["donor"]
    receiver = plan["receiver"]
    path = plan["path"]
    
    if len(path) == 2:  # å•è·³
        # å‘é€æ–¹æ‰£é™¤ï¼šå‘é€èƒ½é‡ + WETæ¨¡å—å¼€é”€ + é€šä¿¡æŸè€—
        energy_sent = plan.get("energy_sent", donor.E_char)
        comm_cost = donor.energy_consumption(receiver, transfer_WET=True)
        donor.current_energy -= comm_cost
        
        # æ¥æ”¶æ–¹è·å¾—ï¼šå‘é€èƒ½é‡ Ã— ä¼ è¾“æ•ˆç‡
        eta = donor.energy_transfer_efficiency(receiver)
        receiver.current_energy += energy_sent * eta
        
    else:  # å¤šè·³
        for i in range(len(path) - 1):
            sender = path[i]
            receiver_i = path[i + 1]
            
            # æ¯ä¸€è·³éƒ½æ‰£é™¤é€šä¿¡èƒ½è€—
            transfer_WET = (i == 0)
            sender.current_energy -= sender.energy_consumption(receiver_i, transfer_WET)
            
            # é€è·³ä¼ é€’èƒ½é‡ï¼ˆæœ‰æŸè€—ï¼‰
            eta = sender.energy_transfer_efficiency(receiver_i)
            receiver_i.current_energy += energy_left * eta
            energy_left = energy_left * eta
```

**ä¿®æ”¹ï¼š**
- `donor.current_energy` â†“
- `receiver.current_energy` â†‘
- `ä¸­ç»§èŠ‚ç‚¹.current_energy` â†“ï¼ˆå¤šè·³ï¼‰

---

### **3. ADCRé€šä¿¡ï¼ˆæŒ‰å‘¨æœŸè§¦å‘ï¼‰**

```python
# src/acdr/adcr_link_layer.py - _settle_comm_energy()

# é˜¶æ®µ1ï¼šç°‡å†…é€šä¿¡ï¼ˆæˆå‘˜ â†’ ç°‡å¤´ï¼‰
for member in cluster_members:
    Eu_member, Ev_ch = self._energy_consume_one_hop(member, ch_node)
    member.current_energy -= Eu_member  # æˆå‘˜æ‰£èƒ½
    ch_node.current_energy -= Ev_ch     # ç°‡å¤´æ‰£èƒ½

# é˜¶æ®µ2ï¼šç°‡é—´é€šä¿¡ï¼ˆç°‡å¤´ â†’ é”šç‚¹ï¼‰
for i in range(len(path) - 1):
    sender.current_energy -= Eu
    receiver.current_energy -= Ev

# é˜¶æ®µ3ï¼šè™šæ‹Ÿè·³ï¼ˆé”šç‚¹ â†’ è™šæ‹Ÿä¸­å¿ƒï¼‰
E_virtual = vc.settle_virtual_hop_energy(last_real, data_size)
last_real.current_energy -= E_virtual  # åªæ‰£é”šç‚¹èƒ½é‡
```

**ä¿®æ”¹ï¼š**
- `ç°‡æˆå‘˜.current_energy` â†“
- `ç°‡å¤´.current_energy` â†“
- `é”šç‚¹.current_energy` â†“

---

## ğŸ“‹ **èƒ½é‡ä½¿ç”¨æ€»ç»“è¡¨**

| é˜¶æ®µ | æ“ä½œ | è¯»å–èƒ½é‡ | ä¿®æ”¹èƒ½é‡ | é¢‘ç‡ |
|------|------|----------|----------|------|
| **1. è‡ªç„¶æ›´æ–°** | `update_network_energy()` | âŒ | âœ… æ‰€æœ‰èŠ‚ç‚¹ | æ¯åˆ†é’Ÿ |
| **2. ADCR** | `adcr_link.step()` | âœ… é€‰ç°‡å¤´ | âœ… é€šä¿¡èŠ‚ç‚¹ | æ¯24å°æ—¶ |
| **3. è°ƒåº¦è§„åˆ’** | `scheduler.plan()` | âœ… æ‰€æœ‰èŠ‚ç‚¹ | âŒ | æŒ‰è§¦å‘ |
| **4. è·¯ç”±è§„åˆ’** | `eeor_find_path()` | âŒ | âŒ | æŒ‰éœ€ |
| **5. ä¼ èƒ½æ‰§è¡Œ** | `execute_energy_transfer()` | âŒ | âœ… donor/receiver/ä¸­ç»§ | æŒ‰è§¦å‘ |
| **6. ç»Ÿè®¡è®°å½•** | `record_stats()` | âœ… æ‰€æœ‰èŠ‚ç‚¹ | âŒ | æŒ‰è§¦å‘ |

---

## ğŸ”‘ **å…³é”®è®¾è®¡åŸåˆ™**

### **1. å•ä¸€æ•°æ®æºï¼ˆSingle Source of Truthï¼‰**
```python
# æ‰€æœ‰ç®—æ³•éƒ½è¯»å†™åŒä¸€ä¸ªå±æ€§
node.current_energy  # â† å”¯ä¸€çš„èƒ½é‡æ¥æº
```

### **2. èŒè´£åˆ†ç¦»**
- **è°ƒåº¦ç®—æ³•**ï¼šå†³å®š**è°ä¼ ç»™è°**ï¼ˆåŸºäºèƒ½é‡çŠ¶æ€ï¼‰
- **è·¯ç”±ç®—æ³•**ï¼šå†³å®š**å¦‚ä½•ä¼ é€’**ï¼ˆåŸºäºé“¾è·¯è´¨é‡ï¼‰
- **ç½‘ç»œå±‚**ï¼šæ‰§è¡Œ**å®é™…ä¼ èƒ½**ï¼ˆä¿®æ”¹èƒ½é‡ï¼‰

### **3. è¯»å†™åˆ†ç¦»**
- **è¯»å–**ï¼šè°ƒåº¦ã€ç»Ÿè®¡ã€ADCRé€‰ä¸¾
- **å†™å…¥**ï¼šè‡ªç„¶æ›´æ–°ã€ä¼ èƒ½æ‰§è¡Œã€ADCRé€šä¿¡

### **4. æ—¶åºä¸€è‡´æ€§**
```
æ¯ä¸ªæ—¶é—´æ­¥çš„é¡ºåºï¼š
  è‡ªç„¶æ›´æ–° â†’ ADCRé€šä¿¡ â†’ è°ƒåº¦è§„åˆ’ â†’ ä¼ èƒ½æ‰§è¡Œ â†’ ç»Ÿè®¡è®°å½•
  â†“          â†“          â†“          â†“          â†“
  ä¿®æ”¹èƒ½é‡    ä¿®æ”¹èƒ½é‡    è¯»å–èƒ½é‡    ä¿®æ”¹èƒ½é‡    è¯»å–èƒ½é‡
```

---

## ğŸ¯ **èƒ½é‡ä¸€è‡´æ€§ä¿è¯**

### **é—®é¢˜ï¼šå¤šå¤„ä¿®æ”¹èƒ½é‡ä¼šä¸ä¼šå†²çªï¼Ÿ**

**ç­”ï¼šä¸ä¼šï¼Œå› ä¸ºï¼š**

1. **ä¸¥æ ¼çš„æ—¶åºæ§åˆ¶**ï¼š
   - å•çº¿ç¨‹æ‰§è¡Œï¼ŒæŒ‰å›ºå®šé¡ºåº
   - æ¯ä¸ªé˜¶æ®µå®Œæˆåæ‰è¿›å…¥ä¸‹ä¸€é˜¶æ®µ

2. **æ˜ç¡®çš„ä¿®æ”¹æ—¶æœº**ï¼š
   - è‡ªç„¶æ›´æ–°ï¼šæ¯åˆ†é’Ÿå¼€å§‹
   - ADCRé€šä¿¡ï¼š24å°æ—¶å‘¨æœŸ
   - WETä¼ èƒ½ï¼šè¢«åŠ¨è§¦å‘ï¼ˆæœ‰å†·å´æœŸï¼‰

3. **åŸå­æ“ä½œ**ï¼š
   ```python
   # æ¯æ¬¡ä¿®æ”¹éƒ½æ˜¯åŸå­çš„
   node.current_energy -= energy_cost
   node.current_energy += energy_received
   ```

---

## ğŸ“Š **èƒ½é‡æµå‘å›¾**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  SensorNode.current_energy          â”‚
â”‚                   ï¼ˆæ‰€æœ‰èƒ½é‡çš„ä¸­å¿ƒï¼‰                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†‘                           â†“
              â”‚                           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   èƒ½é‡å¢åŠ          â”‚       â”‚   èƒ½é‡å‡å°‘       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†‘                           â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ â€¢ å¤ªé˜³èƒ½é‡‡é›†       â”‚       â”‚ â€¢ è‡ªç„¶è¡°å‡       â”‚
    â”‚ â€¢ WETæ¥æ”¶èƒ½é‡      â”‚       â”‚ â€¢ WETå‘é€èƒ½é‡    â”‚
    â”‚ â€¢ å¤šè·³ä¸­ç»§æ¥æ”¶     â”‚       â”‚ â€¢ é€šä¿¡æŸè€—       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ â€¢ ADCRé€šä¿¡       â”‚
                                â”‚ â€¢ å¤šè·³ä¸­ç»§è½¬å‘   â”‚
                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸš€ **ä¼˜åŒ–å»ºè®®**

### **å½“å‰å®ç°çš„ä¼˜ç‚¹ï¼š**
- âœ… å•ä¸€æ•°æ®æºï¼Œæ˜“äºç»´æŠ¤
- âœ… èŒè´£æ¸…æ™°ï¼Œæ˜“äºç†è§£
- âœ… æ—¶åºæ˜ç¡®ï¼Œä¸ä¼šå†²çª

### **å¯èƒ½çš„æ”¹è¿›æ–¹å‘ï¼š**

1. **èƒ½é‡å†å²è¿½è¸ª**ï¼š
   ```python
   # è®°å½•æ¯æ¬¡èƒ½é‡å˜åŒ–çš„åŸå› 
   node.energy_log.append({
       "time": t,
       "type": "WET_receive",
       "delta": +300,
       "from": donor_id
   })
   ```

2. **èƒ½é‡é¢„ç®—æœºåˆ¶**ï¼š
   ```python
   # è°ƒåº¦æ—¶é¢„ç•™èƒ½é‡ï¼Œé¿å…è¿‡åº¦è§„åˆ’
   node.available_energy = node.current_energy - node.reserved_energy
   ```

3. **èƒ½é‡å®¡è®¡**ï¼š
   ```python
   # æ¯ä¸ªæ—¶é—´æ­¥éªŒè¯èƒ½é‡å®ˆæ’
   total_energy_before = sum(n.current_energy for n in nodes)
   # ... æ‰§è¡Œæ“ä½œ ...
   total_energy_after = sum(n.current_energy for n in nodes)
   assert abs((total_after + losses) - total_before) < epsilon
   ```

---

## âœ… **æ€»ç»“**

### **èƒ½é‡ä½¿ç”¨çš„æ ¸å¿ƒæµç¨‹ï¼š**

1. **å­˜å‚¨**ï¼š`SensorNode.current_energy` æ˜¯å”¯ä¸€æ¥æº
2. **è¯»å–**ï¼šè°ƒåº¦ç®—æ³•è¯»å–æ‰€æœ‰èŠ‚ç‚¹èƒ½é‡ï¼Œè§„åˆ’ä¼ èƒ½
3. **ä¸è¯»å–**ï¼šè·¯ç”±ç®—æ³•ä¸è€ƒè™‘èƒ½é‡ï¼Œåªä¼˜åŒ–è·¯å¾„
4. **ä¿®æ”¹**ï¼š
   - è‡ªç„¶æ›´æ–°ï¼ˆæ¯åˆ†é’Ÿï¼‰
   - ADCRé€šä¿¡ï¼ˆå‘¨æœŸæ€§ï¼‰
   - WETä¼ èƒ½ï¼ˆè§¦å‘å¼ï¼‰
5. **é¡ºåº**ï¼šä¸¥æ ¼çš„æ—¶åºä¿è¯ä¸€è‡´æ€§

### **å…³é”®ç†è§£ï¼š**
- ğŸ“– **è°ƒåº¦ç®—æ³•**ï¼šåŸºäºèƒ½é‡å†³ç­–ï¼Œä½†ä¸ä¿®æ”¹èƒ½é‡
- ğŸ›£ï¸ **è·¯ç”±ç®—æ³•**ï¼šä¸è€ƒè™‘èƒ½é‡ï¼Œåªæ‰¾æœ€ä¼˜è·¯å¾„
- âš¡ **ç½‘ç»œå±‚**ï¼šè´Ÿè´£å®é™…çš„èƒ½é‡ä¿®æ”¹
- ğŸ”„ **èƒ½é‡å®ˆæ’**ï¼šé€šè¿‡ä¸¥æ ¼çš„æ—¶åºæ§åˆ¶ä¿è¯

