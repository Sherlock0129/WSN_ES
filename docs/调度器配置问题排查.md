# 调度器配置问题排查指南

## 问题现象

修改 `simulation_config.py` 中的 `scheduler_type` 后，运行代码时调度器类型没有改变。

## 根本原因

**Python 模块缓存机制**：
- 当 Python 导入一个模块时，会将其缓存在 `sys.modules` 中
- dataclass 的默认值是在**类定义时**确定的，不是每次实例化时读取的
- 修改文件中的默认值后，如果模块已经被导入，需要重新加载模块或重启解释器

## 解决方案

### 方案1：在代码中显式设置（推荐）⭐

**不要修改 `simulation_config.py` 中的默认值**，而是在代码中显式设置：

```python
from config.simulation_config import ConfigManager

# 创建配置管理器
config_manager = ConfigManager()

# 显式设置调度器类型
config_manager.scheduler_config.scheduler_type = "LyapunovScheduler"
# 或者
config_manager.scheduler_config.scheduler_type = "AdaptiveLyapunovScheduler"
# 或者
config_manager.scheduler_config.scheduler_type = "AdaptiveDurationAwareLyapunovScheduler"

# 然后创建网络和调度器
network = config_manager.create_network()
scheduler = create_scheduler(config_manager, network)
```

### 方案2：使用配置文件（JSON）

创建或修改 JSON 配置文件：

```json
{
  "scheduler": {
    "scheduler_type": "LyapunovScheduler"
  }
}
```

然后加载配置：

```python
from config.simulation_config import load_config

config_manager = load_config("config.json")
```

### 方案3：重启 Python 解释器

如果使用 Jupyter Notebook 或交互式 Python：
1. 重启内核/解释器
2. 重新运行代码

## 验证调度器类型

在创建调度器后，检查日志输出：

```
============================================================
创建调度器: LyapunovScheduler
============================================================
使用标准 Lyapunov 调度器
============================================================
```

或者在代码中打印：

```python
print(f"当前调度器类型: {config_manager.scheduler_config.scheduler_type}")
```

## 常见错误

### 错误1：修改文件后直接运行

```python
# ❌ 错误：修改了 simulation_config.py 中的默认值，但模块已缓存
from config.simulation_config import ConfigManager
config_manager = ConfigManager()  # 仍然使用旧的默认值
```

### 错误2：使用全局配置实例

```python
# ❌ 错误：使用了全局缓存的配置实例
from config.simulation_config import get_config
config_manager = get_config()  # 可能使用旧的配置
```

### 正确做法

```python
# ✅ 正确：显式设置调度器类型
from config.simulation_config import ConfigManager
config_manager = ConfigManager()
config_manager.scheduler_config.scheduler_type = "LyapunovScheduler"  # 显式设置
```

## 调试技巧

### 1. 添加调试日志

在 `refactored_main.py` 的 `run_simulation` 函数中，已经添加了调试日志：

```python
logger.info(f"当前调度器类型: {scheduler_type}")
```

### 2. 检查配置值

```python
config_manager = ConfigManager()
print(f"调度器类型: {config_manager.scheduler_config.scheduler_type}")
print(f"所有调度器配置: {config_manager.scheduler_config}")
```

### 3. 验证调度器创建

```python
scheduler = create_scheduler(config_manager, network)
print(f"创建的调度器类型: {type(scheduler).__name__}")
```

## 支持的调度器类型

- `"LyapunovScheduler"` - 标准 Lyapunov 调度器
- `"AdaptiveLyapunovScheduler"` - 自适应参数 Lyapunov 调度器
- `"DurationAwareLyapunovScheduler"` - 传输时长感知 Lyapunov 调度器
- `"AdaptiveDurationAwareLyapunovScheduler"` - 自适应传输时长感知 Lyapunov 调度器（推荐）
- `"ClusterScheduler"` - 聚类调度器
- `"PredictionScheduler"` - 预测调度器
- `"PowerControlScheduler"` - 功率控制调度器
- `"ThresholdScheduler"` - 阈值调度器
- `"BaselineHeuristic"` - 基线启发式调度器

## 示例代码

### 完整示例

```python
from config.simulation_config import ConfigManager
from sim.refactored_main import create_scheduler, run_simulation

# 创建配置管理器
config_manager = ConfigManager()

# 显式设置调度器类型（重要！）
config_manager.scheduler_config.scheduler_type = "AdaptiveDurationAwareLyapunovScheduler"

# 验证设置
print(f"调度器类型: {config_manager.scheduler_config.scheduler_type}")

# 运行仿真
run_simulation()
```

### 使用配置文件

```python
from config.simulation_config import load_config
from sim.refactored_main import run_simulation

# 从 JSON 文件加载配置
config_manager = load_config("my_config.json")

# 运行仿真
run_simulation("my_config.json")
```

## 总结

**最佳实践**：
1. ✅ 在代码中显式设置 `scheduler_type`，而不是修改文件默认值
2. ✅ 使用 JSON 配置文件管理不同场景的配置
3. ✅ 在代码中添加验证日志，确认调度器类型正确

**避免**：
1. ❌ 直接修改 `simulation_config.py` 中的默认值（除非重启解释器）
2. ❌ 依赖全局配置实例的缓存值
3. ❌ 不验证调度器类型就直接运行


