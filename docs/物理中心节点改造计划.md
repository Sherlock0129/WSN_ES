# 物理中心节点改造计划

## 设计决策总结

| 决策项 | 选择 | 说明 |
|--------|------|------|
| **能量模式** | 有限能量，不定期补充 | 初始值比普通节点高（如10倍） |
| **节点ID** | 固定为0 | 其他节点从1开始编号 |
| **能量传输角色** | 完全不参与 | WET中忽略该节点（donor/receiver/relay） |
| **位置确定** | 精确几何中心 | 基于所有普通节点位置计算 |
| **兼容性** | 完全替代虚拟中心 | 保留原有功能，重构实现 |

---

## 实现计划

### **阶段1：基础设施修改**

#### 1.1 SensorNode类扩展
**文件**: `src/core/SensorNode.py`

**修改内容**:
```python
class SensorNode:
    def __init__(self, 
                 node_id: int,
                 position: list,
                 initial_energy: float,
                 # ... 其他参数 ...
                 is_physical_center: bool = False):  # 新增参数
        
        self.node_id = node_id
        self.is_physical_center = is_physical_center
        
        # 如果是物理中心，标记特殊角色
        if self.is_physical_center:
            print(f"[SensorNode] 创建物理中心节点 ID={node_id}, "
                  f"位置=({position[0]:.3f}, {position[1]:.3f}), "
                  f"初始能量={initial_energy:.1f}J")
```

**影响范围**: 低（只是添加属性）

---

#### 1.2 Network类重构
**文件**: `src/core/network.py`

**修改内容**:

##### A. 添加物理中心创建方法
```python
def _create_physical_center_node(self, regular_nodes: List[SensorNode], 
                                 center_initial_energy: float) -> SensorNode:
    """
    创建物理中心节点
    
    特性：
    - node_id = 0（固定）
    - 位置 = 普通节点的几何中心
    - 初始能量 = center_initial_energy（通常是普通节点的10倍）
    - is_physical_center = True
    
    :param regular_nodes: 普通节点列表（用于计算几何中心）
    :param center_initial_energy: 物理中心初始能量
    :return: 物理中心节点
    """
    # 1. 计算几何中心
    center_x = sum(n.position[0] for n in regular_nodes) / len(regular_nodes)
    center_y = sum(n.position[1] for n in regular_nodes) / len(regular_nodes)
    
    # 2. 创建物理中心节点（使用与普通节点相同的参数）
    physical_center = SensorNode(
        node_id=0,  # 固定ID
        position=[center_x, center_y],
        initial_energy=center_initial_energy,
        low_threshold=self.low_threshold,
        high_threshold=self.high_threshold,
        has_solar=False,  # 物理中心不需要太阳能
        is_physical_center=True,  # 标记为物理中心
        # 使用与普通节点相同的通信参数
        capacity=self.capacity,
        voltage=self.voltage,
        energy_char=self.energy_char,
        energy_elec=self.energy_elec,
        epsilon_amp=self.epsilon_amp,
        bit_rate=self.bit_rate,
        tau=self.tau
    )
    
    return physical_center
```

##### B. 修改__init__方法
```python
def __init__(self, 
             num_nodes: int,  # 注意：这是普通节点数量，不包括物理中心
             # ... 其他参数 ...
             enable_physical_center: bool = True,
             center_initial_energy_multiplier: float = 10.0):
    
    # 1. 创建普通节点（ID从1开始）
    regular_nodes = []
    for i in range(num_nodes):
        node = SensorNode(
            node_id=i + 1,  # ID从1开始
            # ... 其他参数 ...
            is_physical_center=False
        )
        regular_nodes.append(node)
    
    # 2. 创建物理中心节点（如果启用）
    self.physical_center = None
    if enable_physical_center:
        center_energy = self.initial_energy * center_initial_energy_multiplier
        self.physical_center = self._create_physical_center_node(
            regular_nodes, 
            center_energy
        )
        # 将物理中心插入nodes列表的开头
        self.nodes = [self.physical_center] + regular_nodes
    else:
        self.nodes = regular_nodes
    
    print(f"[Network] 网络初始化完成: "
          f"普通节点={len(regular_nodes)}, "
          f"物理中心={'启用' if self.physical_center else '禁用'}")
```

##### C. 添加辅助方法
```python
def get_regular_nodes(self) -> List[SensorNode]:
    """获取所有普通节点（排除物理中心）"""
    return [n for n in self.nodes if not n.is_physical_center]

def get_physical_center(self) -> Optional[SensorNode]:
    """获取物理中心节点"""
    return self.physical_center

def update_physical_center_position(self):
    """更新物理中心位置到当前网络的几何中心"""
    if not self.physical_center:
        return
    
    regular_nodes = self.get_regular_nodes()
    center_x = sum(n.position[0] for n in regular_nodes) / len(regular_nodes)
    center_y = sum(n.position[1] for n in regular_nodes) / len(regular_nodes)
    
    self.physical_center.position = [center_x, center_y]
    print(f"[Network] 物理中心位置更新为: ({center_x:.3f}, {center_y:.3f})")
```

**影响范围**: 高（网络创建流程变化）

---

#### 1.3 配置文件修改
**文件**: `src/config/simulation_config.py`

**修改内容**:
```python
@dataclass
class NetworkConfig:
    # ... 现有参数 ...
    
    # 物理中心配置
    enable_physical_center: bool = True  # 是否启用物理中心节点
    center_initial_energy_multiplier: float = 10.0  # 物理中心初始能量倍数
```

```python
class ConfigManager:
    def create_network(self) -> Network:
        return Network(
            # ... 现有参数 ...
            enable_physical_center=self.network_config.enable_physical_center,
            center_initial_energy_multiplier=self.network_config.center_initial_energy_multiplier
        )
```

**影响范围**: 低（配置扩展）

---

### **阶段2：能量传输隔离**

#### 2.1 调度器修改
**文件**: `src/scheduling/schedulers.py`

**修改所有调度器的节点选择逻辑**:

```python
class BaseScheduler:
    def _filter_regular_nodes(self, nodes: List[SensorNode]) -> List[SensorNode]:
        """过滤出普通节点（排除物理中心）"""
        return [n for n in nodes if not n.is_physical_center]

class BaselineHeuristic(BaseScheduler):
    def run_routing(self, nodes, t):
        # 排除物理中心节点
        regular_nodes = self._filter_regular_nodes(nodes)
        
        donors = self._select_donors(regular_nodes)
        receivers = self._select_receivers(regular_nodes)
        # ... 其他逻辑 ...

class PowerControlScheduler(BaseScheduler):
    def run_routing(self, nodes, t):
        # 排除物理中心节点
        regular_nodes = self._filter_regular_nodes(nodes)
        # ... 其他逻辑 ...
```

**需要修改的调度器**:
- ✅ `BaselineHeuristic`
- ✅ `PowerControlScheduler`
- ✅ `EnergyBalanceScheduler`（如果有）
- ✅ 所有自定义调度器

**影响范围**: 中（所有调度器需要修改）

---

#### 2.2 路由算法修改
**文件**: `src/routing/EEOR.py`

**修改EEOR的邻居发现和路径规划**:

```python
def eeor_find_path_adaptive(nodes, src, dst, max_hops=5, t=0):
    """
    EEOR路径规划（排除物理中心作为中继）
    """
    # 1. 过滤候选中继节点（排除物理中心）
    relay_candidates = [n for n in nodes if not n.is_physical_center]
    
    # 2. 目标节点可以是物理中心（用于ADCR上报路径）
    # 但中继节点不能是物理中心
    
    # ... 其他路径规划逻辑 ...
```

**影响范围**: 中（路径规划核心逻辑）

---

### **阶段3：ADCR重构**

#### 3.1 删除锚点相关代码
**文件**: `src/acdr/adcr_link_layer.py`

**删除/修改的方法**:
```python
class ADCRLinkLayerVirtual:
    def __init__(self, net: Network):
        # 删除：self.vc = VirtualCenter(...)
        # 改为：直接使用network的物理中心
        self.physical_center = net.get_physical_center()
        
        if not self.physical_center:
            raise ValueError("[ADCR] 物理中心节点未启用，无法使用ADCR")
```

**删除的方法**:
- ❌ `self.vc.find_anchor()` - 不再需要
- ❌ `self.vc.get_anchor()` - 不再需要
- ❌ `_should_use_direct_transmission()` - 简化逻辑

**修改的方法**:

##### A. 路径规划
```python
def _plan_paths_to_physical_center(self):
    """为簇头规划到物理中心的路径"""
    center_node = self.physical_center
    
    for ch in self.cluster_heads:
        ch_id = ch.node_id
        
        # 情况1：簇头本身就是物理中心（理论上不应该发生）
        if ch is center_node:
            self.upstream_paths[ch_id] = [ch]
            continue
        
        # 情况2：使用EEOR规划多跳路径
        path = eeor_find_path_adaptive(
            nodes=self.net.nodes,
            src=ch,
            dst=center_node,  # 目标是物理中心
            max_hops=5,
            t=0
        )
        
        if path and len(path) >= 2:
            self.upstream_paths[ch_id] = path
            print(f"[ADCR] CH {ch_id} 路径: {' → '.join([str(n.node_id) for n in path])}")
        else:
            # 路径规划失败，记录警告
            print(f"[ADCR] 警告: CH {ch_id} 无法到达物理中心")
            self.upstream_paths[ch_id] = None
```

##### B. 能耗结算
```python
def _settle_comm_energy(self):
    """结算通信能耗（全部真实跳）"""
    self.last_comms = []
    
    for ch_id, path in self.upstream_paths.items():
        if not path or len(path) < 2:
            continue
        
        # 1. 簇内通信：成员 → 簇头
        cluster_members = [nid for nid, cid in self.cluster_of.items() 
                          if cid == ch_id and nid != ch_id]
        ch_node = self.id2node[ch_id]
        
        for member_id in cluster_members:
            member_node = self.id2node[member_id]
            # 簇内通信能耗
            self._energy_consume_one_hop(member_node, ch_node, transfer_WET=False)
        
        # 2. 簇间通信：簇头 → ... → 物理中心
        data_size = self._calculate_cluster_data_size(ch_id)
        
        for i in range(len(path) - 1):
            sender = path[i]
            receiver = path[i + 1]
            
            # 临时修改数据包大小
            orig_B_s = sender.B
            orig_B_r = receiver.B
            sender.B = data_size
            receiver.B = data_size
            
            # 计算能耗
            Eu = sender.energy_consumption(target_node=receiver, transfer_WET=False)
            Ev = receiver.energy_consumption(target_node=sender, transfer_WET=False)
            
            # 恢复数据包大小
            sender.B = orig_B_s
            receiver.B = orig_B_r
            
            # 扣除能量
            sender.current_energy = max(0.0, sender.current_energy - Eu)
            # 如果接收端是物理中心，也扣能量（物理中心有有限能量）
            receiver.current_energy = max(0.0, receiver.current_energy - Ev)
            
            self.last_comms.append({
                'from': sender.node_id,
                'to': receiver.node_id,
                'type': 'inter_cluster_to_center',
                'energy': Eu + Ev,
                'data_size': data_size
            })
```

**关键变化**:
- ✅ 删除虚拟跳概念
- ✅ 全部使用真实跳
- ✅ 物理中心也扣能量（因为有有限能量）

**影响范围**: 高（ADCR核心逻辑）

---

#### 3.2 VirtualCenter类改造
**文件**: `src/acdr/virtual_center.py`

**两种处理方式**:

##### 方式A：重命名并简化（推荐）
```python
# 将VirtualCenter改名为PhysicalCenterHelper
# 功能：辅助物理中心进行信息管理和计算

class PhysicalCenterHelper:
    """
    物理中心辅助类
    
    功能：
    - 节点信息表管理（三级缓存）
    - 位置更新辅助
    - 统计和可视化
    
    注意：不再负责锚点选择和虚拟跳能耗
    """
    
    def __init__(self, physical_center_node: SensorNode, 
                 enable_logging: bool = True,
                 history_size: int = 1000,
                 archive_path: Optional[str] = None):
        self.center_node = physical_center_node
        self.enable_logging = enable_logging
        
        # 保留：节点信息表（三级缓存）
        self.latest_info: Dict[int, Dict] = {}
        self.recent_history: deque = deque(maxlen=history_size)
        self.archive_path = archive_path
        # ... 其他信息表相关功能 ...
    
    # 保留的方法：
    # - update_node_info()
    # - batch_update_node_info()
    # - initialize_node_info()
    # - get_node_info()
    # - get_statistics()
    # - get_visualization_data()
    # ... 等信息管理方法 ...
    
    # 删除的方法：
    # - find_anchor()  ❌
    # - get_anchor()  ❌
    # - plan_paths_from_cluster_heads()  ❌ 移到ADCR
    # - calculate_virtual_hop_energy()  ❌
    # - settle_virtual_hop_energy()  ❌
    
    # 简化的方法：
    def update_position(self, nodes: List[SensorNode]):
        """更新物理中心节点的位置到几何中心"""
        regular_nodes = [n for n in nodes if not n.is_physical_center]
        center_x = sum(n.position[0] for n in regular_nodes) / len(regular_nodes)
        center_y = sum(n.position[1] for n in regular_nodes) / len(regular_nodes)
        
        self.center_node.position = [center_x, center_y]
        self._log(f"[PhysicalCenter] 位置更新为: ({center_x:.3f}, {center_y:.3f})")
```

##### 方式B：完全删除（激进）
```python
# 完全删除VirtualCenter类
# 将信息表功能集成到ADCRLinkLayer或Network中

class ADCRLinkLayerVirtual:
    def __init__(self, net: Network):
        self.physical_center = net.get_physical_center()
        
        # 直接在ADCR中管理节点信息表
        self.node_info_table = {}  # 节点信息表
        # ... 其他功能 ...
```

**推荐**: 方式A（保留信息表功能，删除锚点相关）

**影响范围**: 高（依赖VirtualCenter的代码都需要修改）

---

### **阶段4：PathCollector重构**

#### 4.1 删除虚拟跳相关代码
**文件**: `src/info_collection/path_based_collector.py`

**修改内容**:

##### A. 删除虚拟跳能耗计算
```python
# 删除方法：
# - _calculate_virtual_hop_energy()  ❌

def _settle_energy_consumption(self, path: List[SensorNode]) -> float:
    """
    结算信息收集的能量消耗
    
    能量消耗：
    - 路径逐跳信息传递（全部真实跳）
    - 路径终点就是物理中心（无虚拟跳）
    """
    if len(path) < 1:
        return 0.0
    
    # 只计算路径逐跳能耗（包括到物理中心的最后一跳）
    path_energy = self._calculate_path_hop_energy(path)
    
    self._log(f"[PathCollector] 能量消耗 - 路径逐跳={path_energy:.2f}J")
    
    return path_energy
```

##### B. 修改初始化
```python
def __init__(self, 
             physical_center_node: SensorNode,  # 改为接收SensorNode
             energy_mode: str = "free",
             base_data_size: int = 1000000,
             enable_logging: bool = True,
             batch_update: bool = True):
    
    self.center_node = physical_center_node  # 保存物理中心节点
    self.energy_mode = energy_mode
    # ... 其他初始化 ...
```

**影响范围**: 中（PathCollector核心逻辑）

---

### **阶段5：可视化和统计**

#### 5.1 绘图函数修改
**文件**: 各种可视化脚本

**修改内容**:
```python
def plot_network(nodes, physical_center=None):
    """绘制网络拓扑"""
    # 绘制普通节点
    regular_nodes = [n for n in nodes if not n.is_physical_center]
    xs = [n.position[0] for n in regular_nodes]
    ys = [n.position[1] for n in regular_nodes]
    plt.scatter(xs, ys, c='blue', label='Regular Nodes')
    
    # 绘制物理中心（特殊标记）
    if physical_center:
        plt.scatter([physical_center.position[0]], 
                   [physical_center.position[1]], 
                   c='red', s=200, marker='*', 
                   label='Physical Center', zorder=10)
```

**影响范围**: 低（可视化辅助功能）

---

### **阶段6：测试和验证**

#### 6.1 单元测试
```python
# test_physical_center.py

def test_physical_center_creation():
    """测试物理中心节点创建"""
    network = create_test_network(num_nodes=10, enable_physical_center=True)
    
    # 验证物理中心存在
    assert network.physical_center is not None
    assert network.physical_center.node_id == 0
    assert network.physical_center.is_physical_center == True
    
    # 验证普通节点ID从1开始
    regular_nodes = network.get_regular_nodes()
    assert all(n.node_id >= 1 for n in regular_nodes)
    
    # 验证物理中心位置是几何中心
    center_x = sum(n.position[0] for n in regular_nodes) / len(regular_nodes)
    center_y = sum(n.position[1] for n in regular_nodes) / len(regular_nodes)
    assert abs(network.physical_center.position[0] - center_x) < 0.01
    assert abs(network.physical_center.position[1] - center_y) < 0.01

def test_energy_transfer_isolation():
    """测试能量传输隔离"""
    network = create_test_network(num_nodes=10, enable_physical_center=True)
    scheduler = BaselineHeuristic()
    
    plans = scheduler.run_routing(network.nodes, t=0)
    
    # 验证物理中心不参与能量传输
    center_id = network.physical_center.node_id
    for plan in plans:
        assert plan['donor_id'] != center_id
        assert plan['receiver_id'] != center_id
        # 如果有中继，也不应包含物理中心
        if 'path' in plan:
            assert center_id not in [n.node_id for n in plan['path']]

def test_adcr_paths_to_center():
    """测试ADCR到物理中心的路径"""
    network = create_test_network(num_nodes=30, enable_physical_center=True)
    adcr = ADCRLinkLayerVirtual(network)
    
    adcr.step(t=1440)  # 第一个周期
    
    # 验证所有路径都到达物理中心
    center_id = network.physical_center.node_id
    for ch_id, path in adcr.upstream_paths.items():
        if path:
            assert path[-1].node_id == center_id
```

#### 6.2 集成测试
```python
# test_integration_physical_center.py

def test_full_simulation_with_physical_center():
    """完整仿真测试"""
    config_manager = ConfigManager()
    config_manager.network_config.enable_physical_center = True
    config_manager.network_config.center_initial_energy_multiplier = 10.0
    
    network = config_manager.create_network()
    # 运行完整仿真
    # ... 验证物理中心能量变化 ...
```

---

## 实现顺序建议

### **第1步：基础设施**（最重要）
1. ✅ 修改 `SensorNode`（添加 `is_physical_center`）
2. ✅ 修改 `Network`（创建物理中心节点）
3. ✅ 修改 `simulation_config.py`（添加配置）
4. ✅ 测试网络创建

### **第2步：能量传输隔离**
5. ✅ 修改所有调度器（排除物理中心）
6. ✅ 修改 `EEOR`（排除物理中心作为中继）
7. ✅ 测试能量传输

### **第3步：ADCR重构**
8. ✅ 修改 `ADCRLinkLayerVirtual`（删除锚点逻辑）
9. ✅ 修改路径规划（目标改为物理中心）
10. ✅ 修改能耗结算（删除虚拟跳）
11. ✅ 测试ADCR功能

### **第4步：VirtualCenter改造**
12. ✅ 重命名为 `PhysicalCenterHelper`
13. ✅ 删除锚点和虚拟跳相关方法
14. ✅ 保留信息表功能
15. ✅ 更新所有引用

### **第5步：PathCollector重构**
16. ✅ 修改初始化（接收物理中心节点）
17. ✅ 删除虚拟跳能耗计算
18. ✅ 测试PathCollector

### **第6步：收尾工作**
19. ✅ 更新所有可视化代码
20. ✅ 更新文档
21. ✅ 完整回归测试

---

## 预期效果

### **网络拓扑变化**

**修改前**:
```
节点: [1, 2, 3, ..., 30]  (30个普通节点)
虚拟中心: 逻辑实体，位置=(15.5, 15.5)
锚点: Node 15 (最靠近虚拟中心)
```

**修改后**:
```
节点: [0, 1, 2, 3, ..., 30]  (1个物理中心 + 30个普通节点)
物理中心: Node 0, 位置=(15.5, 15.5), 初始能量=10倍
普通节点: Node 1-30
```

### **通信路径变化**

**修改前**:
```
簇头3 → 中继7 → 中继12 → 锚点15 ──[虚拟跳]──> 虚拟中心
       └────── 真实跳 ──────────┘   └─ 逻辑跳 ─┘
```

**修改后**:
```
簇头3 → 中继7 → 中继12 → 物理中心0
       └──────── 全部真实跳 ──────────┘
```

### **能量消耗变化**

**修改前**:
- 锚点：承担额外的虚拟跳发射能耗
- 虚拟中心：不消耗能量

**修改后**:
- 物理中心：作为接收端消耗能量（E_rx）
- 所有跳都是真实跳，能耗计算一致

---

## 风险和注意事项

### **⚠️ 高风险区域**

1. **节点ID冲突**
   - 现有代码可能假设节点ID从0开始
   - 需要检查所有依赖节点ID的代码

2. **能量传输路径**
   - 确保物理中心完全被排除
   - 包括donor、receiver、relay三种角色

3. **ADCR路径规划**
   - 确保所有簇头都能到达物理中心
   - 处理路径规划失败的情况

4. **物理中心能量耗尽**
   - 物理中心有有限能量，可能耗尽
   - 需要监控物理中心能量变化

### **🔍 需要特别检查的代码**

- [ ] 所有使用 `nodes[0]` 的代码
- [ ] 所有使用 `range(len(nodes))` 的循环
- [ ] 所有假设节点数量的代码
- [ ] 所有可视化代码（节点颜色、标记）
- [ ] 所有统计代码（平均能量等）

---

## 后续优化方向

1. **物理中心能量监控**
   - 添加能量预警机制
   - 可选：能量耗尽后自动切换到新的物理中心

2. **物理中心位置优化**
   - 可选：根据通信负载动态调整位置
   - 可选：支持手动指定位置

3. **多物理中心**
   - 未来扩展：支持多个物理中心（分布式）
   - 负载均衡

---

**准备开始实施！请确认是否按此计划执行。** 🚀

