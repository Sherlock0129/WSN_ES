# 路径信息收集器使用说明

## 概述

`PathBasedInfoCollector`（路径信息收集器）是一个**机会主义信息收集**模块，用于在能量传输过程中自动收集节点信息，无需额外的通信开销。

### 核心思想

- **搭载传输**：信息搭载在能量传输路径上，无额外通信成本
- **分层策略**：
  - **路径内节点**：实时采集最新信息（高新鲜度）
  - **路径外节点**：基于历史数据 + 物理模型估算（低成本）
- **汇聚上报**：路径终点（Receiver）作为信息汇聚点，统一上报给虚拟中心

### 与ADCR对比

| 特性 | ADCR | PathBasedCollector |
|------|------|--------------------|
| **更新频率** | 周期性（24小时） | 机会性（每次传能） |
| **覆盖方式** | 全覆盖（簇头上报） | 部分覆盖 + 估算 |
| **通信开销** | 高（专门的上报） | **零**（搭载在传能路径上） |
| **信息新鲜度** | 中等（24小时内） | 高（实时采集） |
| **能量消耗** | 较高（聚类+上报） | **零**（无额外通信，不扣除节点能量） |
| **适用场景** | 定期全面诊断 | 高频轻量监控 |

---

## 💡 为什么PathCollector不消耗能量？

### 核心原理：信息搭载（Piggyback）

**传统方式（ADCR）：**
```
能量传输 → [完成] → 专门发送上报消息 → 虚拟中心
                     ↑ 需要额外通信，消耗能量
```

**PathCollector方式：**
```
能量传输（已有通信） + 顺便读取节点信息 → 虚拟中心
          ↑ 信息"搭便车"，无额外通信，零能量消耗
```

### 具体场景对比

#### 场景：Node 5 → Node 10 的能量传输

**仅传能（无信息收集）：**
```python
[5] --传输300J（消耗通信能量E_comm）--> [10]
# 能量消耗：E_comm（发送+接收）
```

**PathCollector（信息搭载）：**
```python
[5] --传输300J + Node5信息 + Node10信息--> [10]
     ↑ 信息附加在原有通信中
     ↑ 不增加通信次数
     ↑ 不额外消耗能量（代码中无 node.energy -= xxx）
# 能量消耗：E_comm（与仅传能相同）
```

**ADCR（专门上报）：**
```python
# 第1步：能量传输
[5] --传输300J--> [10]  # 消耗 E_comm

# 第2步：信息上报（24小时后触发）
[5] --上报消息--> [簇头] # 消耗 E_report1
[簇头] --上报消息--> [锚点] # 消耗 E_report2
[锚点] --上报消息--> [虚拟中心] # 消耗 E_report3

# 总能量消耗：E_comm + E_report1 + E_report2 + E_report3
```

### 代码验证

```python
# PathCollector 中只读取，不修改能量
class PathBasedInfoCollector:
    def _collect_real_info(self, path, current_time):
        for node in path:
            info[node.node_id] = {
                'energy': node.current_energy,  # ← 只读，不扣除
                # ...
            }
        return info
    # ✅ 整个类中没有任何 node.energy -= xxx 的操作

# ADCR 会显式扣除能量
class ADCRLinkLayerVirtual:
    def _settle_comm_energy(self):
        for hop in path:
            E_tx = sender.energy_consumption(target)
            sender.current_energy -= E_tx  # ← 显式扣除
            # ...
```

---

## 架构设计

### 类设计（方案2 + 方案1）

```
┌─────────────────────────────────────────────────────────────┐
│                    PathBasedInfoCollector                    │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  核心功能                                             │  │
│  │  • collect_and_report()    主入口                    │  │
│  │  • _collect_real_info()    路径节点实时采集          │  │
│  │  • _estimate_other_nodes() 路径外节点估算            │  │
│  │  • _update_virtual_center() 批量更新虚拟中心         │  │
│  └───────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  估算模型                                             │  │
│  │  • _estimate_energy()      物理模型估算能量          │  │
│  │  • _estimate_solar_harvest() 太阳能采集估算          │  │
│  └───────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  统计与监控                                           │  │
│  │  • get_statistics()        获取统计信息              │  │
│  │  • print_statistics()      打印统计信息              │  │
│  │  • evaluate_estimation_accuracy() 评估估算准确度     │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 集成方式（方案A）

**在 `Network` 类中集成**：

```python
class Network:
    def __init__(self, ...):
        # ...
        self.path_info_collector = None  # 稍后由外部设置
    
    def execute_energy_transfer(self, plans, current_time: int = None):
        for plan in plans:
            # ... 执行能量传输 ...
            
            # ✨ 信息收集（如果启用）
            if self.path_info_collector is not None and current_time is not None:
                self.path_info_collector.collect_and_report(
                    path=path,
                    all_nodes=self.nodes,
                    current_time=current_time
                )
```

---

## 工作流程

### 完整流程图

```
┌──────────────┐
│ 能量传输开始 │
└──────┬───────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 1. 收集路径节点实时信息              │
│    path = [donor, relay, receiver]   │
│    for node in path:                 │
│        info[node] = node.current_energy  │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 2. 估算路径外节点信息                │
│    for node in other_nodes:          │
│        old_info = vc.get_node_info() │
│        new_energy = estimate(old_info)│
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 3. Receiver汇总所有信息              │
│    all_info = real_info + estimated  │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 4. 批量更新虚拟中心                  │
│    vc.batch_update_node_info()       │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────┐
│ 能量传输结束 │
└──────────────┘
```

### 能量估算模型

对于路径外节点，使用以下物理模型估算：

```
E_new = E_old + E_harvest - E_decay

其中：
- E_harvest = 太阳能采集量（如果有太阳能）
- E_decay = decay_rate × time_elapsed
- 置信度 = exp(-λ × time_elapsed)  # 时间越长置信度越低
```

---

## ⚡ 能量消耗模式 ✨ 新增

PathCollector 支持两种能量消耗模式，可通过 `energy_mode` 参数配置：

### 模式1：`energy_mode = "free"`（默认，推荐）

**零能耗模式** - 信息完全搭载在传能路径上

```python
# 配置
path_collector:
  energy_mode: "free"
```

**工作原理：**
```
能量传输（已有通信）
[Donor] --300J--> [Relay] ---> [Receiver]
           ↑ 信息搭载，无额外能量消耗
           
[Receiver] --汇总信息--> [虚拟中心]
           ↑ 搭载上报，无额外能量消耗
```

**特点：**
- ✅ **零额外能量消耗**（节点能量不会因信息收集而减少）
- ✅ 保持PathCollector的核心优势
- ✅ 适合长期监控和网络寿命最大化
- ✅ 代码中不执行任何 `node.energy -= xxx` 操作

**适用场景：**
- 长期运行的WSN
- 关注网络寿命的应用
- 需要高频监控但不希望增加能耗的场景

---

### 模式2：`energy_mode = "full"`

**完全真实模式** - 路径逐跳 + 虚拟跳都消耗能量

```python
# 配置
path_collector:
  energy_mode: "full"
```

**工作原理：**
```
能量传输 + 信息逐跳传递（有能耗）
[Donor] --传能+信息(100bits)--> [Relay] --传能+信息(200bits)--> [Receiver]
        ↑ E_tx1 + E_rx1              ↑ E_tx2 + E_rx2
        
[Receiver] --汇总信息(3000bits)--> [虚拟中心]
           ↑ E_virtual（虚拟跳能耗）
```

**能量计算：**

**1. 路径逐跳能耗**
```python
# 每跳传递累积的信息
for i in range(len(path) - 1):
    sender = path[i]
    receiver = path[i + 1]
    
    # 累积信息大小：前i+1个节点的信息
    info_size = (i + 1) * 100  # bits
    
    # 通信能耗
    E_tx = E_elec * info_size + epsilon_amp * info_size * (distance ** tau)
    E_rx = E_elec * info_size
    
    # 扣除能量
    sender.energy -= E_tx
    receiver.energy -= E_rx
```

**2. 虚拟跳能耗（Receiver → 虚拟中心）**
```python
# 使用虚拟中心的能量结算方法（与ADCR相同）
data_size = num_nodes * 100  # 所有节点信息
E_virtual = vc.settle_virtual_hop_energy(
    sender=receiver,
    data_size=data_size,
    ...
)
receiver.energy -= E_virtual
```

**特点：**
- ✅ **最真实的能量模型**（模拟实际通信开销）
- ✅ 路径逐跳传递信息消耗能量
- ✅ 虚拟跳上报消耗能量（与ADCR相同）
- ❌ 失去"搭载"优势
- ⚠️ 能耗比 `free` 模式高，但仍低于ADCR

**适用场景：**
- 需要精确能量建模的研究
- 对比不同信息收集策略的能量效率
- 验证信息收集的实际能量成本

---

### 模式对比

| 特性 | free 模式 | full 模式 | ADCR（参考） |
|------|----------|----------|--------------|
| **路径逐跳能耗** | ✅ 0J | ❌ 有 | ❌ 有 |
| **虚拟跳能耗** | ✅ 0J | ❌ 有 | ❌ 有 |
| **簇内通信能耗** | ✅ 0J | ✅ 0J | ❌ 有 |
| **总额外能耗** | **0J** | **中等** | **高** |
| **网络寿命影响** | 无影响 | 有影响（但小于ADCR） | 显著影响 |
| **真实性** | 理想化 | 完全真实 | 完全真实 |
| **推荐场景** | 长期监控 | 能量建模研究 | 定期全面诊断 |

### 能量消耗示例（30节点网络，12次传能）

| 模式 | 路径能耗 | 虚拟跳能耗 | 总能耗 | 相比ADCR |
|------|---------|-----------|--------|---------|
| **free** | 0J | 0J | **0J** | -100% ✅ |
| **full** | ~180J | ~60J | **~240J** | -43% |
| **ADCR**（24小时） | - | - | **~420J** | 基准 |

**说明：**
- `free` 模式：完全零能耗，适合长期运行
- `full` 模式：比ADCR节能约43%（无簇内通信开销）
- ADCR：包含簇内通信、簇间通信、虚拟跳的完整开销

---

## 使用方法

### 1. 配置文件启用

在 `src/config/simulation_config.py` 中配置：

```python
@dataclass
class PathCollectorConfig:
    enable_path_collector: bool = True  # ✅ 启用路径收集器
    replace_adcr: bool = False  # 是否替代ADCR
    
    # 估算参数
    decay_rate: float = 5.0  # 自然衰减率（J/分钟）
    use_solar_model: bool = True  # 使用太阳能模型
    
    # 优化选项
    batch_update: bool = True  # 批量更新虚拟中心
    
    # 日志输出
    enable_logging: bool = True  # 启用详细日志
```

### 2. 代码中使用

#### 方式A：使用 ConfigManager（推荐）

```python
from config.simulation_config import ConfigManager

# 1. 创建配置管理器
config_manager = ConfigManager()
config_manager.path_collector_config.enable_path_collector = True

# 2. 创建网络
network = config_manager.create_network()

# 3. 创建ADCR（可选，提供虚拟中心）
if config_manager.simulation_config.enable_adcr_link_layer:
    network.adcr_link = config_manager.create_adcr_link_layer(network)
    vc = network.adcr_link.vc  # 使用ADCR的虚拟中心
else:
    # 创建独立虚拟中心
    from acdr.virtual_center import VirtualCenter
    vc = VirtualCenter(enable_logging=True)
    vc.initialize_node_info(network.nodes, initial_time=0)

# 4. 创建路径收集器
network.path_info_collector = config_manager.create_path_collector(vc)

# 5. 运行模拟（自动在每次传能时收集信息）
# ... 正常运行模拟 ...

# 6. 查看统计
network.path_info_collector.print_statistics()
```

#### 方式B：手动创建

```python
from info_collection.path_based_collector import PathBasedInfoCollector
from acdr.virtual_center import VirtualCenter

# 1. 创建虚拟中心
vc = VirtualCenter(enable_logging=True)
vc.initialize_node_info(all_nodes, initial_time=0)

# 2. 创建路径收集器
collector = PathBasedInfoCollector(
    virtual_center=vc,
    enable_logging=True,
    decay_rate=5.0,
    use_solar_model=True,
    batch_update=True
)

# 3. 在能量传输后手动调用
path = [donor, relay, receiver]
collector.collect_and_report(
    path=path,
    all_nodes=all_nodes,
    current_time=current_time
)
```

### 3. 运行测试

```bash
# 运行完整测试套件
cd D:\develop\Github-repos\WSN_ES
python test_path_collector.py
```

---

## 配置参数详解

### PathCollectorConfig

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `enable_path_collector` | bool | False | 是否启用路径信息收集器 |
| `replace_adcr` | bool | False | 是否替代ADCR（如果True，ADCR仅做聚类不更新虚拟中心）|
| **`energy_mode`** ✨ | str | "free" | **能量消耗模式**：<br/>• `"free"`: 零能耗（默认），信息完全搭载<br/>• `"full"`: 完全真实，路径逐跳+虚拟跳都消耗能量 |
| `decay_rate` | float | 5.0 | 自然衰减率（J/分钟），用于估算路径外节点能量 |
| `use_solar_model` | bool | True | 是否使用太阳能模型进行估算 |
| `batch_update` | bool | True | 是否批量更新虚拟中心（减少开销）|
| `enable_logging` | bool | True | 是否启用详细日志 |

### 调优建议

1. **高频监控场景**：
   - `enable_path_collector = True`
   - `decay_rate = 5.0`（根据实际测量调整）
   - `use_solar_model = True`
   - `enable_logging = True`（查看详细信息）

2. **低开销场景**：
   - `enable_path_collector = True`
   - `batch_update = True`
   - `enable_logging = False`（减少日志输出）

3. **高精度场景**：
   - `enable_path_collector = False`
   - 仅使用ADCR（全覆盖，但低频）
   - 或者两者结合：`enable_path_collector = True` + ADCR定期校准

---

## 输出示例

### 控制台输出

```
[PathCollector] 收集完成 - 实时: 3, 估算: 27, 路径长度: 3, Receiver: Node 12

============================================================
路径信息收集器统计
============================================================
总收集次数: 45
实时信息: 135 (15.0%)
估算信息: 765 (85.0%)
平均每次收集:
  - 实时: 3.0 个节点
  - 估算: 17.0 个节点
============================================================
```

### 虚拟中心数据

通过 `virtual_center_node_info.csv` 查看收集的信息：

```csv
time,node_id,energy,freshness,arrival_time,is_estimated,confidence
100,0,39850.5,100,100,False,1.0
100,3,39820.3,100,100,False,1.0
100,7,39900.1,100,100,False,1.0
100,1,39750.2,0,100,True,0.85
100,2,39730.4,0,100,True,0.85
...
```

---

## 高级特性

### 1. 估算准确度评估

```python
# 评估估算值与实际值的误差
accuracy = collector.evaluate_estimation_accuracy(all_nodes)

print(f"估算节点数: {accuracy['count']}")
print(f"平均绝对误差: {accuracy['avg_absolute_error']:.2f} J")
print(f"平均相对误差: {accuracy['avg_relative_error']*100:.2f}%")
```

### 2. 统计信息查询

```python
# 获取统计信息（字典格式）
stats = collector.get_statistics()

print(f"总收集次数: {stats['total_collections']}")
print(f"实时信息比例: {stats['real_ratio']*100:.2f}%")
print(f"估算信息比例: {stats['estimated_ratio']*100:.2f}%")
```

### 3. 重置统计

```python
# 重置统计信息（开始新一轮实验）
collector.reset_statistics()
```

---

## 注意事项

### 1. 虚拟中心依赖

- 路径收集器**必须**关联一个 `VirtualCenter` 实例
- 可以使用ADCR的虚拟中心，也可以创建独立的虚拟中心
- 如果同时启用ADCR和PathCollector，它们会共享同一个虚拟中心

### 2. 时间参数传递

- `execute_energy_transfer` 必须接收 `current_time` 参数
- 已在 `src/core/energy_simulation.py` 中自动传递

### 3. 能量估算精度

- 估算精度取决于：
  - `decay_rate` 的准确性（需根据实际测量调整）
  - `use_solar_model` 是否启用（太阳能节点）
  - 时间跨度（时间越长，误差越大）
- 建议定期通过ADCR校准虚拟中心数据

### 4. 性能考虑

- 路径收集器的开销非常低（无通信成本）
- 如果节点数量很大（>1000），建议：
  - 设置 `enable_logging = False`（减少日志输出）
  - 设置 `batch_update = True`（批量更新）

---

## 扩展与未来工作

### 可能的扩展方向

1. **自适应估算模型**
   - 根据历史误差动态调整 `decay_rate`
   - 机器学习预测能量变化

2. **选择性更新策略**
   - 只更新能量变化明显的节点
   - 优先更新低能量节点

3. **多虚拟中心**
   - 支持多个虚拟中心（分布式）
   - 虚拟中心之间信息同步

4. **与ADCR协同**
   - ADCR定期校准
   - PathCollector高频更新
   - 置信度融合

---

## 常见问题

### Q1: 路径收集器和ADCR可以同时启用吗？

**A**: 可以！它们会共享同一个虚拟中心。建议：
- ADCR：周期性全面诊断（24小时）
- PathCollector：高频轻量监控（每次传能）

### Q2: 如何提高估算精度？

**A**: 
1. 准确测量并设置 `decay_rate`
2. 启用 `use_solar_model`（如果有太阳能节点）
3. 缩短ADCR周期（定期校准）
4. 增加传能频率（更多实时信息）

### Q3: 路径收集器会增加多少开销？

**A**: 
- **通信开销**：0（信息搭载在传能路径上）
- **计算开销**：极低（O(n)，n为节点数）
- **存储开销**：低（虚拟中心三层缓存）

### Q4: 如何禁用路径收集器？

**A**: 
```python
config_manager.path_collector_config.enable_path_collector = False
```
或者不设置 `network.path_info_collector`（保持为 `None`）

---

## 相关文档

- [虚拟中心节点信息表使用说明](./虚拟中心节点信息表使用说明.md)
- [能量管理逻辑说明](./能量管理逻辑说明.md)
- [ADCR协议说明](../src/acdr/README.md)

---

**版本**: v1.0  
**最后更新**: 2024-10-27  
**作者**: WSN_ES Team

