# 路径信息收集器使用说明

## 概述

`PathBasedInfoCollector`（路径信息收集器）是一个**机会主义信息收集**模块，用于在能量传输过程中自动收集节点信息，无需额外的通信开销。

### 核心思想

- **搭载传输**：信息搭载在能量传输路径上
- **路径节点采集**：只采集路径上节点的信息（高新鲜度）
- **汇聚上报**：路径终点（Receiver）作为路径信息汇聚点，上报路径节点的聚合信息

### 具体示例

**场景：30节点网络，某次传能路径为 a→b→c**

1. **路径节点信息收集**：
   - 节点a、b、c 各自收集信息
   - 信息沿路径聚合到终点c
   - c 将 a、b、c 的聚合信息（固定1B）发给虚拟中心
   - **能量消耗**（取决于模式）：
     - `free`模式：0（信息完全搭载）
     - `full`模式：2跳通信 + 1虚拟跳

2. **非路径节点**：
   - 其他27个节点（d、e、f...）没有参与传能
   - **不做任何处理**（不收集、不估算、不更新）

3. **虚拟中心更新**：
   - 只更新路径节点（a、b、c）的信息
   - 非路径节点（d、e、f...）保持原状

### 与ADCR对比

| 特性 | ADCR | PathBasedCollector |
|------|------|--------------------|
| **更新频率** | 周期性（24小时） | 机会性（每次传能） |
| **覆盖方式** | 全覆盖（簇头上报） | 路径节点覆盖 |
| **通信开销** | 高（专门的上报） | 根据模式（搭载或真实通信） |
| **信息新鲜度** | 中等（24小时内） | 高（实时采集路径节点） |
| **能量消耗** | 较高（聚类+簇内+簇间+虚拟跳） | `free`模式：零 / `full`模式：路径跳+虚拟跳 |
| **适用场景** | 定期全面诊断 | 机会性轻量监控 |

---

## 💡 为什么PathCollector不消耗能量？

### 核心原理：信息搭载（Piggyback）

**传统方式（ADCR）：**
```
能量传输 → [完成] → 专门发送上报消息 → 虚拟中心
                     ↑ 需要额外通信，消耗能量
```

**PathCollector方式：**
```
能量传输（已有通信） + 顺便读取节点信息 → 虚拟中心
          ↑ 信息"搭便车"，无额外通信，零能量消耗
```

### 具体场景对比

#### 场景：Node 5 → Node 10 的能量传输

**仅传能（无信息收集）：**
```python
[5] --传输300J（消耗通信能量E_comm）--> [10]
# 能量消耗：E_comm（发送+接收）
```

**PathCollector（信息搭载）：**
```python
[5] --传输300J + Node5信息 + Node10信息--> [10]
     ↑ 信息附加在原有通信中
     ↑ 不增加通信次数
     ↑ 不额外消耗能量（代码中无 node.energy -= xxx）
# 能量消耗：E_comm（与仅传能相同）
```

**ADCR（专门上报）：**
```python
# 第1步：能量传输
[5] --传输300J--> [10]  # 消耗 E_comm

# 第2步：信息上报（24小时后触发）
[5] --上报消息--> [簇头] # 消耗 E_report1
[簇头] --上报消息--> [锚点] # 消耗 E_report2
[锚点] --上报消息--> [虚拟中心] # 消耗 E_report3

# 总能量消耗：E_comm + E_report1 + E_report2 + E_report3
```

### 代码验证

```python
# PathCollector 中只读取，不修改能量
class PathBasedInfoCollector:
    def _collect_real_info(self, path, current_time):
        for node in path:
            info[node.node_id] = {
                'energy': node.current_energy,  # ← 只读，不扣除
                # ...
            }
        return info
    # ✅ 整个类中没有任何 node.energy -= xxx 的操作

# ADCR 会显式扣除能量
class ADCRLinkLayerVirtual:
    def _settle_comm_energy(self):
        for hop in path:
            E_tx = sender.energy_consumption(target)
            sender.current_energy -= E_tx  # ← 显式扣除
            # ...
```

---

## 架构设计

### 类设计

```
┌─────────────────────────────────────────────────────────────┐
│                    PathBasedInfoCollector                    │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  核心功能                                             │  │
│  │  • collect_and_report()    主入口                    │  │
│  │  • _collect_real_info()    路径节点实时采集          │  │
│  │  • _update_virtual_center() 批量更新虚拟中心         │  │
│  └───────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  能量消耗结算                                         │  │
│  │  • _settle_energy_consumption() 能量消耗结算         │  │
│  │  • _calculate_path_hop_energy() 路径逐跳能耗         │  │
│  │  • _calculate_virtual_hop_energy() 虚拟跳能耗        │  │
│  └───────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  统计与监控                                           │  │
│  │  • get_statistics()        获取统计信息              │  │
│  │  • print_statistics()      打印统计信息              │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 集成方式（方案A）

**在 `Network` 类中集成**：

```python
class Network:
    def __init__(self, ...):
        # ...
        self.path_info_collector = None  # 稍后由外部设置
    
    def execute_energy_transfer(self, plans, current_time: int = None):
        for plan in plans:
            # ... 执行能量传输 ...
            
            # ✨ 信息收集（如果启用）
            if self.path_info_collector is not None and current_time is not None:
                self.path_info_collector.collect_and_report(
                    path=path,
                    all_nodes=self.nodes,
                    current_time=current_time
                )
```

---

## 工作流程

### 完整流程图

```
┌──────────────┐
│ 能量传输开始 │
└──────┬───────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 1. 收集路径节点实时信息              │
│    path = [donor, relay, receiver]   │
│    for node in path:                 │
│        info[node] = node.current_energy  │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 2. 计算能量消耗（如果启用full模式） │
│    - 路径逐跳能耗                    │
│    - 虚拟跳能耗                      │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 3. 更新虚拟中心（只更新路径节点）   │
│    vc.batch_update_node_info(path_info)│
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────┐
│ 能量传输结束 │
└──────────────┘
```

---

## ⚡ 能量消耗模式 ✨ 新增

PathCollector 支持两种能量消耗模式，可通过 `energy_mode` 参数配置：

### 模式1：`energy_mode = "free"`（默认，推荐）

**零能耗模式** - 信息完全搭载在传能路径上

```python
# 配置
path_collector:
  energy_mode: "free"
```

**工作原理：**
```
能量传输（已有通信）
[Donor] --300J--> [Relay] ---> [Receiver]
           ↑ 信息搭载，无额外能量消耗
           
[Receiver] --汇总信息--> [虚拟中心]
           ↑ 搭载上报，无额外能量消耗
```

**特点：**
- ✅ **零额外能量消耗**（节点能量不会因信息收集而减少）
- ✅ 保持PathCollector的核心优势
- ✅ 适合长期监控和网络寿命最大化
- ✅ 代码中不执行任何 `node.energy -= xxx` 操作

**适用场景：**
- 长期运行的WSN
- 关注网络寿命的应用
- 需要高频监控但不希望增加能耗的场景

---

### 模式2：`energy_mode = "full"`

**完全真实模式** - 路径逐跳 + 虚拟跳都消耗能量

```python
# 配置
path_collector:
  energy_mode: "full"
```

**工作原理：**
```
能量传输 + 信息沿路径聚合传递（有能耗）

路径 a → b → c：
[a] 收集自己信息 --传能+信息(1B)--> [b] 收集自己+a的信息
                    ↑ E_tx1 + E_rx1
                    
                    [b] --传能+聚合信息(1B)--> [c] 收集a+b+c的信息
                                          ↑ E_tx2 + E_rx2
                                          固定大小，不累积
        
[c] --路径聚合信息(1B)--> [虚拟中心]
    ↑ E_virtual（虚拟跳能耗）
    只包含路径节点（a、b、c）的聚合信息，固定1B

[虚拟中心] 只更新路径节点（a、b、c）的信息
```

**能量计算：**

**1. 路径逐跳能耗（与ADCR完全一致）** ✅
```python
# 每跳传递固定大小的聚合信息包
data_packet_size = base_data_size  # 固定大小（信息已聚合/压缩，不累积）

for i in range(len(path) - 1):
    sender = path[i]
    receiver = path[i + 1]
    
    # 使用SensorNode.energy_consumption()方法（与ADCR._energy_consume_one_hop一致）
    sender.B = data_packet_size  # 临时修改数据包大小
    receiver.B = data_packet_size
    
    Eu = sender.energy_consumption(target_node=receiver, transfer_WET=False)
    Ev = receiver.energy_consumption(target_node=sender, transfer_WET=False)
    
    # 恢复原始B值并扣除能量
    sender.energy -= Eu  # Eu = [(E_tx + E_rx) / 2 + E_sen]
    receiver.energy -= Ev  # Ev = [(E_tx + E_rx) / 2 + E_sen]
```

**关键特点：**
- ✅ 数据包大小固定为 `base_data_size`（**不随路径长度累积**）
- ✅ 信息沿路径逐跳聚合，最终在**路径终点（Receiver）**汇聚
- ✅ 每一跳传输相同大小的数据包（固定1B）
- ✅ 路径终点将**路径节点**的聚合信息发给虚拟中心
- ✅ 虚拟中心**只更新路径节点**的信息
- ✅ 与ADCR的簇头聚合逻辑一致

**2. 虚拟跳能耗（Receiver → 虚拟中心）（与ADCR完全一致）** ✅
```python
# 使用虚拟中心的能量结算方法（与ADCR相同）
data_size = base_data_size  # 固定大小（信息已聚合/压缩）
E_virtual = vc.settle_virtual_hop_energy(
    sender=receiver,
    data_size=data_size,
    tx_rx_ratio=0.5,
    sensor_energy=0.1
)
# E_virtual = 0.5 * (E_tx + E_rx) + 0.1
receiver.energy -= E_virtual
```

**关键特点：**
- ✅ 数据包大小固定为 `base_data_size`（**不随路径长度或节点数增长**）
- ✅ 包含**路径上所有节点**的聚合信息（例如路径a→b→c，包含3个节点信息）
- ✅ 信息已聚合/压缩到固定大小的数据包（1B）
- ✅ 与ADCR的虚拟跳逻辑一致

**特点：**
- ✅ **最真实的能量模型**（模拟实际通信开销）
- ✅ 路径逐跳传递信息消耗能量
- ✅ 虚拟跳上报消耗能量（与ADCR相同）
- ❌ 失去"搭载"优势
- ⚠️ 能耗比 `free` 模式高，但仍低于ADCR

**适用场景：**
- 需要精确能量建模的研究
- 对比不同信息收集策略的能量效率
- 验证信息收集的实际能量成本

---

### 模式对比

| 特性 | free 模式 | full 模式 | ADCR（参考） |
|------|----------|----------|--------------|
| **路径逐跳能耗** | ✅ 0J | ❌ 有 | ❌ 有 |
| **虚拟跳能耗** | ✅ 0J | ❌ 有 | ❌ 有 |
| **簇内通信能耗** | ✅ 0J | ✅ 0J | ❌ 有 |
| **总额外能耗** | **0J** | **中等** | **高** |
| **网络寿命影响** | 无影响 | 有影响（但小于ADCR） | 显著影响 |
| **真实性** | 理想化 | 完全真实 | 完全真实 |
| **推荐场景** | 长期监控 | 能量建模研究 | 定期全面诊断 |

### 能量消耗示例（30节点网络，12次传能，单跳路径）

| 模式 | 路径能耗 | 虚拟跳能耗 | 簇内通信 | 总能耗 | 相比ADCR |
|------|---------|-----------|---------|--------|---------|
| **free** | 0J | 0J | - | **0J** | -100% ✅ |
| **full** | ~120J | ~40J | 0J | **~160J** | -84% ✅ |
| **ADCR**（24小时） | ~400J | ~120J | ~500J | **~1020J** | 基准 |

**说明：**
- `free` 模式：完全零能耗，适合长期运行
- `full` 模式：比ADCR节能约84%，主要节能来源：
  - ✅ **无簇内通信**（最大节能因素）
  - ✅ **信息聚合**（固定大小数据包，不随节点数增长）
  - ✅ **机会式收集**（搭载在传能路径上）
- ADCR：包含簇内通信（成员→簇头）、簇间通信（簇头→锚点）、虚拟跳的完整开销

**能量计算已与ADCR完全一致：**
- ✅ 使用相同的 `base_data_size = 1,000,000 bits`
- ✅ 使用相同的 `SensorNode.energy_consumption()` 方法
- ✅ 路径逐跳：`[(E_tx + E_rx) / 2 + E_sen] × 2端`，**固定数据包大小**
- ✅ 虚拟跳：`0.5 * (E_tx + E_rx) + 0.1`，**固定数据包大小**
- ✅ 信息聚合模型：
  - **路径节点信息**沿路径聚合到终点，压缩到固定大小数据包（1B）
  - **非路径节点**不收集、不估算、不更新

---

## 使用方法

### 1. 配置文件启用

在 `src/config/simulation_config.py` 中配置：

```python
@dataclass
class PathCollectorConfig:
    # 基本开关
    enable_path_collector: bool = True  # ✅ 启用路径收集器
    replace_adcr: bool = False  # 是否替代ADCR
    
    # 能量消耗模式
    energy_mode: str = "free"  # "free": 零能耗（搭载）
                                # "full": 完全真实通信能耗
    
    # 数据包大小配置
    base_data_size: int = 1000000  # 基础数据大小（bits），与ADCR一致
    
    # 优化选项
    batch_update: bool = True  # 批量更新虚拟中心
    
    # 日志输出
    enable_logging: bool = True  # 启用详细日志
```

### 2. 代码中使用

#### 方式A：使用 ConfigManager（推荐）

```python
from config.simulation_config import ConfigManager

# 1. 创建配置管理器
config_manager = ConfigManager()
config_manager.path_collector_config.enable_path_collector = True

# 2. 创建网络
network = config_manager.create_network()

# 3. 创建ADCR（可选，提供虚拟中心）
if config_manager.simulation_config.enable_adcr_link_layer:
    network.adcr_link = config_manager.create_adcr_link_layer(network)
    vc = network.adcr_link.vc  # 使用ADCR的虚拟中心
else:
    # 创建独立虚拟中心
    from acdr.virtual_center import VirtualCenter
    vc = VirtualCenter(enable_logging=True)
    vc.initialize_node_info(network.nodes, initial_time=0)

# 4. 创建路径收集器
network.path_info_collector = config_manager.create_path_collector(vc)

# 5. 运行模拟（自动在每次传能时收集信息）
# ... 正常运行模拟 ...

# 6. 查看统计
network.path_info_collector.print_statistics()
```

#### 方式B：手动创建

```python
from info_collection.path_based_collector import PathBasedInfoCollector
from acdr.virtual_center import VirtualCenter

# 1. 创建虚拟中心
vc = VirtualCenter(enable_logging=True)
vc.initialize_node_info(all_nodes, initial_time=0)

# 2. 创建路径收集器
collector = PathBasedInfoCollector(
    virtual_center=vc,
    energy_mode="free",  # 或 "full"
    base_data_size=1000000,  # 与ADCR一致
    enable_logging=True,
    batch_update=True
)

# 3. 在能量传输后手动调用
path = [donor, relay, receiver]
collector.collect_and_report(
    path=path,
    all_nodes=all_nodes,
    current_time=current_time
)
```

### 3. 运行测试

```bash
# 运行完整测试套件
cd D:\develop\Github-repos\WSN_ES
python test_path_collector.py
```

---

## 配置参数详解

### PathCollectorConfig

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `enable_path_collector` | bool | False | 是否启用路径信息收集器 |
| `replace_adcr` | bool | False | 是否替代ADCR（如果True，ADCR仅做聚类不更新虚拟中心）|
| **`energy_mode`** ✨ | str | "free" | **能量消耗模式**：<br/>• `"free"`: 零能耗（默认），信息完全搭载<br/>• `"full"`: 完全真实，路径逐跳+虚拟跳都消耗能量 |
| `base_data_size` | int | 1000000 | 基础数据大小（bits），与ADCR保持一致 |
| `batch_update` | bool | True | 是否批量更新虚拟中心（减少开销）|
| `enable_logging` | bool | True | 是否启用详细日志 |

### 调优建议

1. **理想化场景（长期监控）**：
   - `enable_path_collector = True`
   - `energy_mode = "free"`（零能耗）
   - `batch_update = True`
   - `enable_logging = False`（减少日志输出）

2. **真实能量建模场景**：
   - `enable_path_collector = True`
   - `energy_mode = "full"`（完全真实）
   - `base_data_size = 1000000`（与ADCR一致）
   - `enable_logging = True`（查看详细能量消耗）

3. **与ADCR对比场景**：
   - PathCollector + ADCR同时启用
   - `replace_adcr = False`（两者并行运行）
   - 对比两种方法的信息新鲜度和能量开销

---

## 输出示例

### 控制台输出

```
[PathCollector] 收集完成 - 路径节点: 3, 路径长度: 3, Receiver: Node 12

============================================================
路径信息收集器统计
============================================================
能量模式: free
总收集次数: 45
收集的路径节点数: 135
平均每次收集: 3.0 个路径节点
============================================================

（如果启用 energy_mode="full"）
能量消耗:
  - 总计: 160.50 J
  - 平均每次: 3.57 J
============================================================
```

### 虚拟中心数据

通过 `virtual_center_node_info.csv` 查看收集的信息：

```csv
time,node_id,energy,freshness,arrival_time,is_estimated,confidence
100,0,39850.5,100,100,False,1.0
100,3,39820.3,100,100,False,1.0
100,7,39900.1,100,100,False,1.0
100,1,39750.2,0,100,True,0.85
100,2,39730.4,0,100,True,0.85
...
```

---

## 高级特性

### 1. 统计信息查询

```python
# 获取统计信息（字典格式）
stats = collector.get_statistics()

print(f"总收集次数: {stats['total_collections']}")
print(f"路径节点数: {stats['total_real_info']}")
print(f"平均每次收集: {stats['avg_real_per_collection']:.1f} 个路径节点")
if energy_mode == "full":
    print(f"总能量消耗: {stats['total_energy_consumed']:.2f} J")
    print(f"平均每次能量: {stats['avg_energy_per_collection']:.2f} J")
```

### 2. 重置统计

```python
# 重置统计信息（开始新一轮实验）
collector.reset_statistics()
```

---

## 注意事项

### 1. 虚拟中心依赖

- 路径收集器**必须**关联一个 `VirtualCenter` 实例
- 可以使用ADCR的虚拟中心，也可以创建独立的虚拟中心
- 如果同时启用ADCR和PathCollector，它们会共享同一个虚拟中心

### 2. 时间参数传递

- `execute_energy_transfer` 必须接收 `current_time` 参数
- 已在 `src/core/energy_simulation.py` 中自动传递

### 3. 性能考虑

- `free`模式：路径收集器的开销非常低（无通信成本）
- `full`模式：有真实的通信能耗，但仍低于ADCR
- 如果节点数量很大（>1000），建议：
  - 设置 `enable_logging = False`（减少日志输出）
  - 设置 `batch_update = True`（批量更新）

### 4. 信息覆盖率

- PathCollector只更新路径节点，覆盖率取决于能量传输的频率和路径分布
- 如果需要全网信息，建议：
  - 结合ADCR使用（PathCollector提供高频更新，ADCR提供全覆盖）
  - 设置 `replace_adcr = False`（两者并行运行）

---

## 扩展与未来工作

### 可能的扩展方向

1. **非路径节点的估算**
   - 基于历史信息+物理模型估算非路径节点能量
   - 需要权衡：估算精度 vs 计算开销

2. **选择性更新策略**
   - 只更新能量变化明显的节点
   - 优先更新低能量节点

3. **多虚拟中心**
   - 支持多个虚拟中心（分布式）
   - 虚拟中心之间信息同步

4. **与ADCR协同**
   - ADCR定期校准
   - PathCollector高频更新
   - 置信度融合

---

## 常见问题

### Q1: 路径收集器和ADCR可以同时启用吗？

**A**: 可以！它们会共享同一个虚拟中心。建议：
- ADCR：周期性全面诊断（24小时）
- PathCollector：高频轻量监控（每次传能）

### Q2: PathCollector只更新路径节点，会不会信息不全？

**A**: 
- PathCollector的设计目标是**机会主义轻量监控**，而非全覆盖
- 如果需要全网信息，可以：
  1. 结合ADCR使用（PathCollector高频更新 + ADCR全覆盖）
  2. 增加传能频率（更多路径 = 更多覆盖）
  3. 使用后续可能的扩展：非路径节点估算

### Q3: 路径收集器会增加多少开销？

**A**: 
- **通信开销**（`free`模式）：0（信息完全搭载）
- **通信开销**（`full`模式）：有真实开销，但低于ADCR（无簇内通信）
- **计算开销**：极低（O(path_nodes)，只处理路径节点）
- **存储开销**：低（虚拟中心三层缓存）

### Q4: 如何禁用路径收集器？

**A**: 
```python
config_manager.path_collector_config.enable_path_collector = False
```
或者不设置 `network.path_info_collector`（保持为 `None`）

---

## 相关文档

- [虚拟中心节点信息表使用说明](./虚拟中心节点信息表使用说明.md)
- [能量管理逻辑说明](./能量管理逻辑说明.md)
- [ADCR协议说明](../src/acdr/README.md)

---

**版本**: v1.0  
**最后更新**: 2024-10-27  
**作者**: WSN_ES Team

