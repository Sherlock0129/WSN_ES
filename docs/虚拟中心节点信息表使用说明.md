# 虚拟中心节点信息表使用说明

## 📋 功能概述

虚拟中心现在集成了一个**三级缓存的节点信息表**，用于记录和管理所有节点的状态信息，包括：
- 节点编号
- 当前能量
- 信息新鲜度（采集时间）
- 信息到达虚拟中心的时间
- 节点位置、太阳能状态、簇ID等扩展信息

---

## 🏗️ 三级缓存架构（方案3）

```
┌──────────────────────────────────────────────────────┐
│  L1: 最新状态表（latest_info）                       │
│  • 数据结构: Dict[node_id, info_dict]                │
│  • 查询复杂度: O(1)                                   │
│  • 用途: 快速获取节点最新状态                         │
└──────────────────────────────────────────────────────┘
                        ↓
┌──────────────────────────────────────────────────────┐
│  L2: 近期历史（recent_history）                      │
│  • 数据结构: deque(maxlen=1000)                      │
│  • 用途: 时序分析、趋势追踪                           │
│  • 特性: 固定大小，自动淘汰旧记录                     │
└──────────────────────────────────────────────────────┘
                        ↓
┌──────────────────────────────────────────────────────┐
│  L3: 长期归档（CSV文件）                             │
│  • 文件路径: data/[session]/virtual_center_node_info.csv │
│  • 批量写入: 每100条记录批量刷新                      │
│  • 用途: 持久化存储、离线分析                         │
└──────────────────────────────────────────────────────┘
```

---

## 📊 节点信息表结构

### L1: 最新状态表

```python
{
    node_id: {
        'energy': float,           # 节点当前能量（J）
        'freshness': int,          # 信息采集时间（分钟）
        'arrival_time': int,       # 到达虚拟中心时间（分钟）
        'position': (x, y),        # 节点位置坐标
        'is_solar': bool,          # 是否有太阳能
        'cluster_id': int,         # 所属簇ID
        'data_size': int,          # 数据包大小（bits）
        'age': int                 # 信息年龄 = arrival_time - freshness
    }
}
```

### L3: 归档CSV文件

| 列名 | 类型 | 说明 |
|------|------|------|
| `arrival_time` | int | 到达虚拟中心时间（分钟） |
| `node_id` | int | 节点ID |
| `energy` | float | 节点能量（J） |
| `freshness` | int | 信息采集时间（分钟） |
| `age` | int | 信息年龄（分钟） |
| `position_x` | float | X坐标 |
| `position_y` | float | Y坐标 |
| `is_solar` | bool | 是否有太阳能 |
| `cluster_id` | int | 所属簇ID |
| `data_size` | int | 数据包大小（bits） |

---

## 🔧 使用方法

### 1. 自动集成（无需修改代码）

节点信息表已经集成到ADCR协议中，**自动运行**：

```python
# 运行仿真（正常流程）
python src/sim/refactored_main.py

# 自动发生的事情：
# 0. ADCR创建时：立即填充所有节点的初始状态（t=0）✨ 新增
# 1. ADCR每24小时执行一次
# 2. 通信结算后，自动更新所有节点信息到虚拟中心
# 3. 每100条记录自动批量写入CSV文件
# 4. 仿真结束时强制刷新剩余记录
```

**初始值自动填充：**
- ✅ ADCR创建后立即填充所有节点初始信息
- ✅ 使用 `node.initial_energy` 作为初始能量
- ✅ 时间戳设为 t=0
- ✅ 初始时无簇分配（cluster_id=None）

### 2. 手动更新单个节点

```python
# 在ADCR或其他模块中手动更新节点信息
adcr.vc.update_node_info(
    node_id=5,
    energy=1200.5,
    freshness=1440,      # 第1天结束
    arrival_time=1440,   # 同时到达
    position=(5.0, 5.0),
    is_solar=True,
    cluster_id=2,
    data_size=5000
)
```

### 3. 批量更新所有节点

```python
# 批量更新（ADCR自动调用）
adcr.vc.batch_update_node_info(
    nodes=network.nodes,
    current_time=t,
    cluster_mapping=adcr.cluster_of,  # {node_id: cluster_id}
    data_sizes={ch_id: data_size}     # {node_id: data_size}
)
```

---

## 📖 查询接口

### 1. 获取单个节点最新信息

```python
# 查询Node 5的最新信息
info = adcr.vc.get_node_info(5)

if info:
    print(f"Node 5 能量: {info['energy']}J")
    print(f"信息年龄: {info['age']}分钟")
    print(f"所属簇: {info['cluster_id']}")

# 在仿真开始前就可以查询初始值 ✨
# 因为ADCR创建时已经填充了所有节点的初始信息
# 例如在 t=0 时：
# info['energy'] = node.initial_energy (如 40000.0)
# info['freshness'] = 0
# info['cluster_id'] = None
```

### 2. 获取所有节点信息

```python
# 获取所有节点的最新状态
all_info = adcr.vc.get_all_nodes_info()

for node_id, info in all_info.items():
    print(f"Node {node_id}: {info['energy']:.1f}J, 簇{info['cluster_id']}")
```

### 3. 获取信息过期的节点

```python
# 获取信息年龄超过30分钟的节点
stale_nodes = adcr.vc.get_stale_nodes(
    current_time=1500,
    staleness_threshold=30  # 30分钟
)

print(f"过期节点: {stale_nodes}")
```

### 4. 获取低能量节点

```python
# 获取能量低于1000J的节点
low_energy_nodes = adcr.vc.get_low_energy_nodes(
    energy_threshold=1000.0
)

# 返回: [(node_id, energy), ...] 按能量升序排序
for node_id, energy in low_energy_nodes:
    print(f"Node {node_id}: {energy:.1f}J")
```

### 5. 获取统计信息

```python
# 获取整体统计
stats = adcr.vc.get_statistics()

print(f"节点总数: {stats['total_nodes']}")
print(f"平均能量: {stats['avg_energy']:.1f}J")
print(f"最低能量: {stats['min_energy']:.1f}J")
print(f"平均信息年龄: {stats['avg_age']:.1f}分钟")
print(f"太阳能节点: {stats['solar_nodes']}")
print(f"历史记录: {stats['history_records']}")
```

### 6. 获取历史记录

```python
# 获取最近100条历史记录
history = adcr.vc.get_recent_history(limit=100)

for record in history:
    arrival_time, node_id, energy, freshness, position, is_solar, cluster_id, data_size = record
    print(f"[{arrival_time}] Node {node_id}: {energy:.1f}J")
```

---

## 📂 输出文件

### 归档文件位置

```
data/
└── 20251027_120000/              # 会话目录（自动生成）
    ├── virtual_center_node_info.csv  # ← 节点信息表归档
    ├── energy_over_time.png
    ├── node_distribution.png
    └── simulation_results.csv
```

### 归档文件示例

```csv
arrival_time,node_id,energy,freshness,age,position_x,position_y,is_solar,cluster_id,data_size
0,0,40000.0,0,0,1.5,2.3,True,,,                # ← 初始值（t=0）✨
0,1,40000.0,0,0,3.7,4.1,False,,,               # ← 初始值（t=0）✨
0,2,40000.0,0,0,6.2,1.8,True,,,                # ← 初始值（t=0）✨
1440,0,38500.2,1440,0,1.5,2.3,True,0,5000     # ← 第1次ADCR更新
1440,1,38120.5,1440,0,3.7,4.1,False,0,5000    # ← 第1次ADCR更新
1440,2,39800.0,1440,0,6.2,1.8,True,1,8000     # ← 第1次ADCR更新
2880,0,37200.3,2880,0,1.5,2.3,True,0,5000     # ← 第2次ADCR更新
2880,1,36850.5,2880,0,3.7,4.1,False,0,5000    # ← 第2次ADCR更新
...
```

**说明：**
- 第一批记录（t=0）：网络创建时的初始状态，所有节点能量为初始值
- 后续记录：ADCR每24小时更新一次，记录能量变化和簇分配

---

## 🎯 应用场景

### 场景1：网络状态监控

```python
# 监控网络整体健康度
stats = adcr.vc.get_statistics()

if stats['min_energy'] < 100:
    print("⚠️ 警告：有节点能量过低！")
    
if stats['avg_age'] > 60:
    print("⚠️ 警告：信息更新滞后！")
```

### 场景2：智能调度决策

```python
# 基于虚拟中心的信息进行调度决策
def schedule_based_on_vc_info(vc, current_time):
    # 1. 获取低能量节点
    low_energy = vc.get_low_energy_nodes(threshold=500)
    
    # 2. 排除信息过期的节点
    stale = set(vc.get_stale_nodes(current_time, staleness_threshold=30))
    
    # 3. 筛选有效目标
    valid_targets = [(nid, e) for nid, e in low_energy if nid not in stale]
    
    return valid_targets
```

### 场景3：信息新鲜度分析

```python
# 分析信息延迟
all_info = adcr.vc.get_all_nodes_info()

ages = [info['age'] for info in all_info.values()]
print(f"信息年龄统计：")
print(f"  最小: {min(ages)}分钟")
print(f"  平均: {sum(ages)/len(ages):.1f}分钟")
print(f"  最大: {max(ages)}分钟")
```

### 场景4：离线数据分析

```python
import pandas as pd

# 读取归档文件
df = pd.read_csv("data/20251027_120000/virtual_center_node_info.csv")

# 分析能量变化趋势
node_0_energy = df[df['node_id'] == 0]['energy']
print(f"Node 0 能量变化: {node_0_energy.describe()}")

# 分析信息延迟分布
print(f"信息年龄分布:\n{df['age'].describe()}")

# 可视化
import matplotlib.pyplot as plt
df.groupby('arrival_time')['energy'].mean().plot()
plt.title('平均能量随时间变化')
plt.show()
```

---

## ⚙️ 配置参数

### VirtualCenter初始化参数

```python
vc = VirtualCenter(
    initial_position=(5.0, 5.0),       # 初始位置
    update_strategy="geometric_center", # 位置更新策略
    enable_logging=True,                # 是否启用日志
    history_size=1000,                  # L2缓存大小（条）
    archive_path="data/vc_info.csv"     # L3归档路径
)
```

### 批量写入配置

```python
# 修改批量写入大小（默认100）
vc.archive_batch_size = 200  # 每200条记录写入一次
```

---

## 🔍 调试信息

### 启用详细日志

```python
# VirtualCenter 已默认启用日志
# 完整的控制台输出示例：

# ========== ADCR创建时（初始化） ==========
# [ADCR] 初始化虚拟中心节点信息表...
# [VirtualCenter] 开始初始化节点信息表，节点数: 30
# [VirtualCenter] 更新节点信息: Node 0, 能量=40000.0J, 新鲜度=0, 到达时间=0, 信息年龄=0分钟
# [VirtualCenter] 更新节点信息: Node 1, 能量=40000.0J, 新鲜度=0, 到达时间=0, 信息年龄=0分钟
# ... (所有节点)
# [VirtualCenter] 节点信息表初始化完成，记录数: 30
# [VirtualCenter] 初始统计 - 平均能量: 40000.0J, 太阳能节点: 18/30
# [ADCR] 虚拟中心节点信息表初始化完成，已记录 30 个节点

# ========== ADCR执行时（每24小时更新） ==========
# [VirtualCenter] 更新节点信息: Node 5, 能量=38500.2J, 新鲜度=1440, 到达时间=1440, 信息年龄=0分钟
# [VirtualCenter] 批量更新 30 个节点信息
# [VirtualCenter] 归档 100 条记录到 data/20251027_120000/virtual_center_node_info.csv
# [ADCR] 虚拟中心节点信息表已更新，当前记录: 30 个节点

# ========== 仿真结束时 ==========
# [VirtualCenter] 强制刷新归档完成
# [ADCR] 虚拟中心归档已保存
```

### 查看当前状态

```python
# 查看内存占用情况
stats = vc.get_statistics()
print(f"L1 记录数: {stats['total_nodes']}")
print(f"L2 记录数: {stats['history_records']}")
print(f"L3 缓冲区: {stats['archive_buffer_size']}")
```

---

## 💡 最佳实践

### 1. 定期强制刷新

```python
# 在重要时刻强制刷新归档
if t % 1440 == 0:  # 每天结束时
    vc.force_flush_archive()
```

### 2. 内存管理

```python
# 对于长时间运行的仿真，控制L2缓存大小
vc = VirtualCenter(
    history_size=500,  # 减小到500条
    archive_batch_size=50  # 更频繁地写入磁盘
)
```

### 3. 性能优化

```python
# 对于大规模网络（>1000节点）
# 建议：
# - history_size = 500
# - archive_batch_size = 50
# - 禁用详细日志：enable_logging=False
```

### 4. 数据分析

```python
# 仿真结束后分析
import pandas as pd

df = pd.read_csv("data/latest/virtual_center_node_info.csv")

# 按簇分组分析
cluster_stats = df.groupby('cluster_id').agg({
    'energy': ['mean', 'std', 'min', 'max'],
    'age': ['mean', 'max']
})
print(cluster_stats)
```

---

## 📈 性能指标

| 操作 | 时间复杂度 | 空间复杂度 |
|------|-----------|-----------|
| 更新单个节点 | O(1) | O(1) |
| 批量更新N个节点 | O(N) | O(N) |
| 查询单个节点 | O(1) | - |
| 获取所有节点 | O(N) | O(N) |
| 获取低能量节点 | O(N) | O(K) |
| 获取过期节点 | O(N) | O(K) |
| 写入归档（批量） | O(B) | O(B) |

*注：N=节点总数，K=结果集大小，B=批量大小*

---

## ⚠️ 注意事项

1. **自动集成**：已集成到ADCR中，无需手动调用
2. **文件路径**：归档文件自动生成在 `data/[session]/virtual_center_node_info.csv`
3. **批量写入**：每100条记录自动写入，减少磁盘I/O
4. **强制刷新**：仿真结束时自动强制刷新，确保所有数据持久化
5. **信息年龄**：`age = arrival_time - freshness`，表示信息的延迟
6. **内存控制**：L2缓存固定大小（默认1000），自动淘汰旧记录

---

## 🚀 未来扩展

### 可能的增强功能：

1. **SQL数据库支持**
   ```python
   vc = VirtualCenter(
       archive_backend="sqlite",
       archive_path="vc_info.db"
   )
   ```

2. **实时查询优化**
   ```python
   # 添加索引支持
   vc.create_index('energy')
   low_nodes = vc.query("energy < 500")
   ```

3. **数据压缩**
   ```python
   # 对历史数据进行压缩
   vc.enable_compression(algorithm='gzip')
   ```

4. **多虚拟中心同步**
   ```python
   # 多个虚拟中心之间同步信息
   vc1.sync_with(vc2)
   ```

---

## ✅ 总结

虚拟中心节点信息表提供了一个**高效、灵活、可扩展**的节点状态管理方案：

- ✅ **三级缓存**：平衡内存和性能
- ✅ **自动初始化**：ADCR创建时立即填充所有节点初始值 ✨ 新增
- ✅ **自动更新**：ADCR每24小时自动更新所有节点状态
- ✅ **持久化存储**：自动保存到CSV文件
- ✅ **丰富API**：支持多种查询方式
- ✅ **易于分析**：标准CSV格式，兼容pandas

**文件输出**：`data/[session_dir]/virtual_center_node_info.csv`

**时间线：**
```
t=0      → 初始化：填充所有节点初始值（initial_energy）
t=1440   → 第1次ADCR更新：记录能量变化 + 簇分配
t=2880   → 第2次ADCR更新：记录能量变化 + 簇分配
...      → 持续更新
结束时   → 强制刷新：确保所有数据持久化
```

