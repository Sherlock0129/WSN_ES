# 虚拟中心节点信息表使用说明

## 📋 功能概述

虚拟中心现在集成了一个**三级缓存的节点信息表**，用于记录和管理所有节点的状态信息，包括：
- 节点编号
- 当前能量
- 信息新鲜度（采集时间）
- 信息到达虚拟中心的时间
- 节点位置、太阳能状态、簇ID等扩展信息

### 🔄 两种信息收集方式

**方式1：ADCR协议（定期收集）**
- ⏰ 每24小时执行一次
- 📡 专用通信收集所有节点信息
- ✅ 信息准确、完整
- ❌ 通信开销较大、频率固定

**方式2：路径信息收集器（机会式收集）** ✨ 新增
- ⚡ 每次能量传输时自动收集
- 🚀 搭载在传能路径上（可配置能量消耗）
- ✅ 更新频率高、信息新鲜
- 🔍 路径节点实时采集 + 非路径节点基于模型估算
- ⚙️ **可配置能量模式**：
  - `free`（默认）：零能耗，信息完全搭载
  - `full`：完全真实，路径逐跳+虚拟跳都消耗能量

---

## 🏗️ 三级缓存架构（方案3）

```
┌──────────────────────────────────────────────────────┐
│  L1: 最新状态表（latest_info）                       │
│  • 数据结构: Dict[node_id, info_dict]                │
│  • 查询复杂度: O(1)                                   │
│  • 用途: 快速获取节点最新状态                         │
└──────────────────────────────────────────────────────┘
                        ↓
┌──────────────────────────────────────────────────────┐
│  L2: 近期历史（recent_history）                      │
│  • 数据结构: deque(maxlen=1000)                      │
│  • 用途: 时序分析、趋势追踪                           │
│  • 特性: 固定大小，自动淘汰旧记录                     │
└──────────────────────────────────────────────────────┘
                        ↓
┌──────────────────────────────────────────────────────┐
│  L3: 长期归档（CSV文件）                             │
│  • 文件路径: data/[session]/virtual_center_node_info.csv │
│  • 批量写入: 每100条记录批量刷新                      │
│  • 用途: 持久化存储、离线分析                         │
└──────────────────────────────────────────────────────┘
```

---

## 📊 节点信息表结构

### L1: 最新状态表

```python
{
    node_id: {
        'energy': float,           # 节点当前能量（J）
        'freshness': int,          # 信息采集时间（分钟）
        'arrival_time': int,       # 到达虚拟中心时间（分钟）
        'position': (x, y),        # 节点位置坐标
        'is_solar': bool,          # 是否有太阳能
        'cluster_id': int,         # 所属簇ID
        'data_size': int,          # 数据包大小（bits）
        'age': int                 # 信息年龄 = arrival_time - freshness
    }
}
```

### L3: 归档CSV文件

| 列名 | 类型 | 说明 |
|------|------|------|
| `arrival_time` | int | 到达虚拟中心时间（分钟） |
| `node_id` | int | 节点ID |
| `energy` | float | 节点能量（J） |
| `freshness` | int | 信息采集时间（分钟） |
| `age` | int | 信息年龄（分钟） |
| `position_x` | float | X坐标 |
| `position_y` | float | Y坐标 |
| `is_solar` | bool | 是否有太阳能 |
| `cluster_id` | int | 所属簇ID |
| `data_size` | int | 数据包大小（bits） |

---

## 🔧 使用方法

### 1. 配置方式选择

#### 方式1：使用ADCR（定期收集）

编辑 `config/simulation_config.yaml`：

```yaml
adcr:
  enable_adcr: true
  update_interval: 1440  # 24小时更新一次
  
path_collector:
  enable_path_collector: false  # 不使用路径收集器
```

**特点：**
- ✅ 信息准确、完整
- ⏰ 固定周期更新（24小时）
- 📡 有专用通信开销

#### 方式2：使用路径信息收集器（机会式收集）✨ 推荐

编辑 `config/simulation_config.yaml`：

```yaml
adcr:
  enable_adcr: false  # 不使用ADCR
  
path_collector:
  enable_path_collector: true   # 启用路径收集器
  replace_adcr: true             # 替代ADCR的信息收集
  energy_mode: "free"            # 能量模式："free"（零能耗）或 "full"（完全真实）✨
  decay_rate: 5.0                # 自然衰减率（J/分钟）
  use_solar_model: true          # 使用太阳能模型估算
  batch_update: true             # 批量更新虚拟中心
  enable_logging: true           # 启用详细日志
```

**特点：**
- ⚡ 高频更新（每次传能时）
- 🚀 **零额外通信开销（energy_mode="free"）**
- 🔍 实时采集 + 模型估算
- 🔧 可配置能量模式（默认零能耗）

#### 方式3：混合模式（同时使用）

```yaml
adcr:
  enable_adcr: true
  update_interval: 1440
  
path_collector:
  enable_path_collector: true
  replace_adcr: false  # ADCR继续做聚类和更新
  # ... 其他参数
```

**特点：**
- 🔄 结合两种方式的优势
- 📊 PathCollector提供高频更新
- 🎯 ADCR提供周期性精确校准

---

### 2. 自动运行流程

无论使用哪种方式，**节点信息表都会自动运行**：

```python
# 运行仿真（正常流程）
python src/sim/refactored_main.py

# 自动发生的事情：
# 0. 网络创建时：立即填充所有节点的初始状态（t=0）
# 1a. 如果启用ADCR：每24小时更新所有节点信息
# 1b. 如果启用PathCollector：每次传能时更新路径节点 + 估算其他节点
# 2. 每100条记录自动批量写入CSV文件
# 3. 仿真结束时强制刷新剩余记录
```

**初始值自动填充：**
- ✅ 网络创建时立即填充所有节点初始信息
- ✅ 使用 `node.initial_energy` 作为初始能量
- ✅ 时间戳设为 t=0
- ✅ 初始时无簇分配（cluster_id=None）

### 3. 手动更新单个节点（高级用法）

```python
# 在ADCR或PathCollector中手动更新节点信息
vc.update_node_info(
    node_id=5,
    energy=1200.5,
    freshness=1440,      # 第1天结束
    arrival_time=1440,   # 同时到达
    position=(5.0, 5.0),
    is_solar=True,
    cluster_id=2,
    data_size=5000
)
```

### 4. 批量更新所有节点（高级用法）

```python
# 批量更新（ADCR或PathCollector自动调用）
vc.batch_update_node_info(
    nodes=network.nodes,
    current_time=t,
    cluster_mapping=cluster_of,  # {node_id: cluster_id}
    data_sizes={ch_id: data_size}     # {node_id: data_size}
)
```

---

## 📖 查询接口

### 1. 获取单个节点最新信息

```python
# 查询Node 5的最新信息
info = adcr.vc.get_node_info(5)

if info:
    print(f"Node 5 能量: {info['energy']}J")
    print(f"信息年龄: {info['age']}分钟")
    print(f"所属簇: {info['cluster_id']}")

# 在仿真开始前就可以查询初始值 ✨
# 因为ADCR创建时已经填充了所有节点的初始信息
# 例如在 t=0 时：
# info['energy'] = node.initial_energy (如 40000.0)
# info['freshness'] = 0
# info['cluster_id'] = None
```

### 2. 获取所有节点信息

```python
# 获取所有节点的最新状态
all_info = adcr.vc.get_all_nodes_info()

for node_id, info in all_info.items():
    print(f"Node {node_id}: {info['energy']:.1f}J, 簇{info['cluster_id']}")
```

### 3. 获取信息过期的节点

```python
# 获取信息年龄超过30分钟的节点
stale_nodes = adcr.vc.get_stale_nodes(
    current_time=1500,
    staleness_threshold=30  # 30分钟
)

print(f"过期节点: {stale_nodes}")
```

### 4. 获取低能量节点

```python
# 获取能量低于1000J的节点
low_energy_nodes = adcr.vc.get_low_energy_nodes(
    energy_threshold=1000.0
)

# 返回: [(node_id, energy), ...] 按能量升序排序
for node_id, energy in low_energy_nodes:
    print(f"Node {node_id}: {energy:.1f}J")
```

### 5. 获取统计信息

```python
# 获取整体统计
stats = adcr.vc.get_statistics()

print(f"节点总数: {stats['total_nodes']}")
print(f"平均能量: {stats['avg_energy']:.1f}J")
print(f"最低能量: {stats['min_energy']:.1f}J")
print(f"平均信息年龄: {stats['avg_age']:.1f}分钟")
print(f"太阳能节点: {stats['solar_nodes']}")
print(f"历史记录: {stats['history_records']}")
```

### 6. 获取历史记录

```python
# 获取最近100条历史记录
history = adcr.vc.get_recent_history(limit=100)

for record in history:
    arrival_time, node_id, energy, freshness, position, is_solar, cluster_id, data_size = record
    print(f"[{arrival_time}] Node {node_id}: {energy:.1f}J")
```

---

## 📂 输出文件

### 归档文件位置

```
data/
└── 20251027_120000/              # 会话目录（自动生成）
    ├── virtual_center_node_info.csv  # ← 节点信息表归档
    ├── energy_over_time.png
    ├── node_distribution.png
    └── simulation_results.csv
```

### 归档文件示例

#### 示例1：使用ADCR（定期收集）

```csv
arrival_time,node_id,energy,freshness,age,position_x,position_y,is_solar,cluster_id,data_size
0,0,40000.0,0,0,1.5,2.3,True,,,                # ← 初始值（t=0）
0,1,40000.0,0,0,3.7,4.1,False,,,               # ← 初始值（t=0）
0,2,40000.0,0,0,6.2,1.8,True,,,                # ← 初始值（t=0）
1440,0,38500.2,1440,0,1.5,2.3,True,0,5000     # ← 第1次ADCR更新（24小时后）
1440,1,38120.5,1440,0,3.7,4.1,False,0,5000    # ← 第1次ADCR更新
1440,2,39800.0,1440,0,6.2,1.8,True,1,8000     # ← 第1次ADCR更新
2880,0,37200.3,2880,0,1.5,2.3,True,0,5000     # ← 第2次ADCR更新（48小时后）
2880,1,36850.5,2880,0,3.7,4.1,False,0,5000    # ← 第2次ADCR更新
...
```

**特点：**
- 每24小时更新一次所有节点
- 信息年龄（age）为0（实时采集）
- 记录包含簇分配信息

#### 示例2：使用PathCollector（机会式收集）✨ 新增

```csv
arrival_time,node_id,energy,freshness,age,position_x,position_y,is_solar,cluster_id,data_size
0,0,40000.0,0,0,1.5,2.3,True,,,                # ← 初始值（t=0）
0,1,40000.0,0,0,3.7,4.1,False,,,               # ← 初始值（t=0）
0,2,40000.0,0,0,6.2,1.8,True,,,                # ← 初始值（t=0）
180,0,39850.5,180,0,1.5,2.3,True,,,            # ← PathCollector更新（能量传输时）
180,1,39800.2,180,0,3.7,4.1,False,,,           # ← PathCollector更新
180,2,39900.1,180,0,6.2,1.8,True,,,            # ← PathCollector更新
190,5,39700.3,190,0,5.1,3.2,True,,,            # ← PathCollector更新（路径节点实时）
190,8,39650.0,185,5,8.3,4.7,False,,,           # ← PathCollector更新（非路径节点估算，age=5）
195,0,39840.1,195,0,1.5,2.3,True,,,            # ← PathCollector再次更新
200,3,39500.0,190,10,3.5,6.1,True,,,           # ← PathCollector更新（估算，age=10）
...
```

**特点：**
- 每次能量传输时更新（频率高达数十次/小时）
- 路径节点：信息年龄为0（实时采集）
- 非路径节点：信息年龄>0（基于模型估算）
- 无簇分配信息（cluster_id为空）

#### 示例3：混合模式（ADCR + PathCollector）

```csv
arrival_time,node_id,energy,freshness,age,position_x,position_y,is_solar,cluster_id,data_size
0,0,40000.0,0,0,1.5,2.3,True,,,                # ← 初始值
180,0,39850.5,180,0,1.5,2.3,True,,,            # ← PathCollector高频更新
190,5,39700.3,190,0,5.1,3.2,True,,,            # ← PathCollector高频更新
1440,0,38500.2,1440,0,1.5,2.3,True,0,5000     # ← ADCR精确校准 + 簇分配
1450,5,38400.1,1450,0,5.1,3.2,True,0,,         # ← PathCollector继续高频更新
2880,0,37200.3,2880,0,1.5,2.3,True,0,5000     # ← ADCR再次精确校准
...
```

**特点：**
- PathCollector提供高频更新（每次传能）
- ADCR提供周期性精确校准（每24小时）
- 结合两种方式的优势

---

## 🎯 应用场景

### 场景1：网络状态监控

```python
# 监控网络整体健康度
stats = adcr.vc.get_statistics()

if stats['min_energy'] < 100:
    print("⚠️ 警告：有节点能量过低！")
    
if stats['avg_age'] > 60:
    print("⚠️ 警告：信息更新滞后！")
```

### 场景2：智能调度决策

```python
# 基于虚拟中心的信息进行调度决策
def schedule_based_on_vc_info(vc, current_time):
    # 1. 获取低能量节点
    low_energy = vc.get_low_energy_nodes(threshold=500)
    
    # 2. 排除信息过期的节点
    stale = set(vc.get_stale_nodes(current_time, staleness_threshold=30))
    
    # 3. 筛选有效目标
    valid_targets = [(nid, e) for nid, e in low_energy if nid not in stale]
    
    return valid_targets
```

### 场景2.5：PathCollector高频监控 ✨ 新增

```python
# PathCollector提供实时节点状态监控
# 每次传能后自动更新，无需等待24小时

# 1. 实时检测节点能量危机
if network.path_info_collector:
    stats = network.path_info_collector.vc.get_statistics()
    
    if stats['min_energy'] < 200:
        print(f"⚠️ 紧急：节点能量过低！最低能量: {stats['min_energy']:.1f}J")
        # 触发紧急传能
        emergency_transfer(low_energy_nodes)

# 2. 基于新鲜信息的智能决策
def smart_schedule_with_path_collector(vc, current_time):
    # PathCollector提供的信息更新鲜（age更小）
    all_info = vc.get_all_nodes_info()
    
    # 筛选新鲜信息（age < 5分钟）
    fresh_nodes = {nid: info for nid, info in all_info.items() if info['age'] < 5}
    
    # 基于新鲜信息做决策
    targets = [(nid, info['energy']) for nid, info in fresh_nodes.items() 
               if info['energy'] < 500]
    
    return sorted(targets, key=lambda x: x[1])  # 按能量升序
```

### 场景3：信息新鲜度分析

```python
# 分析信息延迟
all_info = adcr.vc.get_all_nodes_info()

ages = [info['age'] for info in all_info.values()]
print(f"信息年龄统计：")
print(f"  最小: {min(ages)}分钟")
print(f"  平均: {sum(ages)/len(ages):.1f}分钟")
print(f"  最大: {max(ages)}分钟")
```

### 场景4：离线数据分析

```python
import pandas as pd

# 读取归档文件
df = pd.read_csv("data/20251027_120000/virtual_center_node_info.csv")

# 分析能量变化趋势
node_0_energy = df[df['node_id'] == 0]['energy']
print(f"Node 0 能量变化: {node_0_energy.describe()}")

# 分析信息延迟分布
print(f"信息年龄分布:\n{df['age'].describe()}")

# 可视化
import matplotlib.pyplot as plt
df.groupby('arrival_time')['energy'].mean().plot()
plt.title('平均能量随时间变化')
plt.show()
```

---

## ⚙️ 配置参数

### VirtualCenter初始化参数

```python
vc = VirtualCenter(
    initial_position=(5.0, 5.0),       # 初始位置
    update_strategy="geometric_center", # 位置更新策略
    enable_logging=True,                # 是否启用日志
    history_size=1000,                  # L2缓存大小（条）
    archive_path="data/vc_info.csv"     # L3归档路径
)
```

### 批量写入配置

```python
# 修改批量写入大小（默认100）
vc.archive_batch_size = 200  # 每200条记录写入一次
```

---

## 🔍 调试信息

### 方式1：ADCR日志输出

```python
# ========== ADCR创建时（初始化） ==========
[ADCR] 初始化虚拟中心节点信息表...
[VirtualCenter] 开始初始化节点信息表，节点数: 30
[VirtualCenter] 更新节点信息: Node 0, 能量=40000.0J, 新鲜度=0, 到达时间=0, 信息年龄=0分钟
[VirtualCenter] 更新节点信息: Node 1, 能量=40000.0J, 新鲜度=0, 到达时间=0, 信息年龄=0分钟
... (所有节点)
[VirtualCenter] 节点信息表初始化完成，记录数: 30
[VirtualCenter] 初始统计 - 平均能量: 40000.0J, 太阳能节点: 18/30
[ADCR] 虚拟中心节点信息表初始化完成，已记录 30 个节点

# ========== ADCR执行时（每24小时更新） ==========
[VirtualCenter] 更新节点信息: Node 5, 能量=38500.2J, 新鲜度=1440, 到达时间=1440, 信息年龄=0分钟
[VirtualCenter] 批量更新 30 个节点信息
[VirtualCenter] 归档 100 条记录到 data/20251027_120000/virtual_center_node_info.csv
[ADCR] 虚拟中心节点信息表已更新，当前记录: 30 个节点

# ========== 仿真结束时 ==========
[VirtualCenter] 强制刷新归档完成
[ADCR] 虚拟中心归档已保存
```

### 方式2：PathCollector日志输出 ✨ 新增

```python
# ========== PathCollector创建时（初始化） ==========
[PathCollector] 路径信息收集器已创建
[PathCollector] 配置: decay_rate=5.0, use_solar_model=True, batch_update=True
[VirtualCenter] 开始初始化节点信息表，节点数: 30
[VirtualCenter] 节点信息表初始化完成，记录数: 30

# ========== 能量传输时（每次自动触发） ==========
[智能被动传能] 时间步 180: 能量变异系数=0.100>0.100
[Direct WET] 5 → 10, η=0.52, +522.52J, loss=477.48J
[PathCollector] 收集完成 - 实时: 2, 估算: 28, 路径长度: 2, Receiver: Node 10
[VirtualCenter] 批量更新 30 个节点信息

[Direct WET] 25 → 17, η=0.76, +759.96J, loss=240.04J
[PathCollector] 收集完成 - 实时: 2, 估算: 28, 路径长度: 2, Receiver: Node 17
[VirtualCenter] 批量更新 30 个节点信息

# ========== 多跳传能时 ==========
  [Hop 1] 3 → 1, d=0.86m, η=0.655, +654.65J, loss=345.35J
  [Hop 2] 1 → 10, d=1.32m, η=0.344, +225.24J, loss=429.41J
[PathCollector] 收集完成 - 实时: 3, 估算: 27, 路径长度: 3, Receiver: Node 10
[VirtualCenter] 批量更新 30 个节点信息

# ========== 归档批量写入 ==========
[VirtualCenter] 归档 100 条记录到 data/20251028_030232/virtual_center_node_info.csv

# ========== 仿真结束时统计 ==========
[PathCollector] ===== 路径信息收集器统计 =====
[PathCollector] 总收集次数: 150
[PathCollector] 实时信息收集: 380 次
[PathCollector] 估算信息收集: 4120 次
[PathCollector] 平均路径长度: 2.5 跳
[PathCollector] 收集成功率: 100.0%
[VirtualCenter] 强制刷新归档完成
```

**PathCollector日志说明：**
- `实时: N` - 路径节点数量（直接采集）
- `估算: M` - 非路径节点数量（模型估算）
- `路径长度` - 传能路径跳数
- 每次传能自动触发，无需等待24小时

### 查看当前状态

```python
# 查看内存占用情况
stats = vc.get_statistics()
print(f"L1 记录数: {stats['total_nodes']}")
print(f"L2 记录数: {stats['history_records']}")
print(f"L3 缓冲区: {stats['archive_buffer_size']}")
```

---

## 💡 最佳实践

### 1. 定期强制刷新

```python
# 在重要时刻强制刷新归档
if t % 1440 == 0:  # 每天结束时
    vc.force_flush_archive()
```

### 2. 内存管理

```python
# 对于长时间运行的仿真，控制L2缓存大小
vc = VirtualCenter(
    history_size=500,  # 减小到500条
    archive_batch_size=50  # 更频繁地写入磁盘
)
```

### 3. 性能优化

```python
# 对于大规模网络（>1000节点）
# 建议：
# - history_size = 500
# - archive_batch_size = 50
# - 禁用详细日志：enable_logging=False
```

### 4. 数据分析

```python
# 仿真结束后分析
import pandas as pd

df = pd.read_csv("data/latest/virtual_center_node_info.csv")

# 按簇分组分析
cluster_stats = df.groupby('cluster_id').agg({
    'energy': ['mean', 'std', 'min', 'max'],
    'age': ['mean', 'max']
})
print(cluster_stats)
```

---

## 📈 性能指标

| 操作 | 时间复杂度 | 空间复杂度 |
|------|-----------|-----------|
| 更新单个节点 | O(1) | O(1) |
| 批量更新N个节点 | O(N) | O(N) |
| 查询单个节点 | O(1) | - |
| 获取所有节点 | O(N) | O(N) |
| 获取低能量节点 | O(N) | O(K) |
| 获取过期节点 | O(N) | O(K) |
| 写入归档（批量） | O(B) | O(B) |

*注：N=节点总数，K=结果集大小，B=批量大小*

---

## ⚠️ 注意事项

### 通用注意事项

1. **自动集成**：已集成到ADCR和PathCollector中，无需手动调用
2. **文件路径**：归档文件自动生成在 `data/[session]/virtual_center_node_info.csv`
3. **批量写入**：每100条记录自动写入，减少磁盘I/O
4. **强制刷新**：仿真结束时自动强制刷新，确保所有数据持久化
5. **信息年龄**：`age = arrival_time - freshness`，表示信息的延迟
6. **内存控制**：L2缓存固定大小（默认1000），自动淘汰旧记录

### PathCollector特有注意事项 ✨

1. **估算精度**：非路径节点使用模型估算，精度取决于 `decay_rate` 和 `use_solar_model` 参数
2. **信息年龄差异**：路径节点age=0（实时），非路径节点age>0（估算延迟）
3. **更新频率**：与传能频率相关，传能越频繁更新越多
4. **无簇信息**：PathCollector不包含簇分配信息（cluster_id为空）
5. **文件权限**：确保 `archive_path` 是**文件路径**而非目录路径

---

## 🚀 未来扩展

### 可能的增强功能：

1. **SQL数据库支持**
   ```python
   vc = VirtualCenter(
       archive_backend="sqlite",
       archive_path="vc_info.db"
   )
   ```

2. **实时查询优化**
   ```python
   # 添加索引支持
   vc.create_index('energy')
   low_nodes = vc.query("energy < 500")
   ```

3. **数据压缩**
   ```python
   # 对历史数据进行压缩
   vc.enable_compression(algorithm='gzip')
   ```

4. **多虚拟中心同步**
   ```python
   # 多个虚拟中心之间同步信息
   vc1.sync_with(vc2)
   ```

---

## ✅ 总结

虚拟中心节点信息表提供了一个**高效、灵活、可扩展**的节点状态管理方案：

- ✅ **三级缓存**：平衡内存和性能
- ✅ **自动初始化**：ADCR创建时立即填充所有节点初始值 ✨ 新增
- ✅ **自动更新**：ADCR每24小时自动更新所有节点状态
- ✅ **持久化存储**：自动保存到CSV文件
- ✅ **丰富API**：支持多种查询方式
- ✅ **易于分析**：标准CSV格式，兼容pandas

**文件输出**：`data/[session_dir]/virtual_center_node_info.csv`

**时间线：**
```
t=0      → 初始化：填充所有节点初始值（initial_energy）
t=1440   → 第1次ADCR更新：记录能量变化 + 簇分配
t=2880   → 第2次ADCR更新：记录能量变化 + 簇分配
...      → 持续更新
结束时   → 强制刷新：确保所有数据持久化
```

